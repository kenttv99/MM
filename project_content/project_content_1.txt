Project Files Content
================
File: constants.py
# constants.py

"""
Модуль с константами проекта
"""

# Используется в database/init_db.py и database/drop_db.py
DATABASE_URL = "postgresql+asyncpg://postgres:assasin88@localhost:5432/moscow_mellows"

# Все три константы используются в api/auth.py
SECRET_KEY = "123456789"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

RATE_LIMITS = {
    "register": "20/minute",      # 20 регистраций в минуту
    "login": "60/minute",         # 60 попыток входа в минуту
    "access_me": "60/minute",     # 60 запросов к /me в минуту
    "verify_token": "600/minute",  # 600 запросов проверки токена в минуту (10 в секунду)
    "verify_token_admin": "100/minute"
}
================
File: backend\api\admin_auth_routers.py
from fastapi import APIRouter, Depends, HTTPException, status, Request
from backend.schemas_enums.schemas import AdminCreate, AdminLogin, AdminResponse
from backend.config.auth import create_admin, get_admin_by_username, pwd_context, create_access_token, get_current_admin, log_admin_activity
from backend.database.user_db import AsyncSession, get_async_db
from backend.config.logging_config import logger
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from datetime import timedelta
from backend.config.rate_limiter import rate_limit
from constants import ACCESS_TOKEN_EXPIRE_MINUTES

router = APIRouter()

bearer_scheme = HTTPBearer()

@router.post("/register", response_model=AdminResponse, status_code=status.HTTP_201_CREATED)
@rate_limit("register_admin")  # Лимит определяется в constants.py
async def register_admin(admin: AdminCreate, db: AsyncSession = Depends(get_async_db), request: Request = None):
    """Регистрация нового администратора."""
    existing_admin = await get_admin_by_username(db, admin.email)
    if existing_admin:
        logger.warning(f"Attempt to register existing admin email: {admin.email}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already exists"
        )
    
    try:
        new_admin = await create_admin(db, admin.fio, admin.email, admin.password)
        await log_admin_activity(db, new_admin.id, request, action="register")
        logger.info(f"Admin registered successfully: {new_admin.email}")
        return new_admin
    except Exception as e:
        logger.error(f"Error registering admin: {str(e)}")
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to register admin"
        )

@router.post("/login")
@rate_limit("login_admin")  # Лимит определяется в constants.py
async def login_admin(admin: AdminLogin, db: AsyncSession = Depends(get_async_db), request: Request = None):
    """Авторизация администратора с возвратом токена."""
    db_admin = await get_admin_by_username(db, admin.email)
    if not db_admin or not pwd_context.verify(admin.password, db_admin.password_hash):
        await log_admin_activity(db, db_admin.id if db_admin else None, request, action="login_failed")
        logger.warning(f"Failed login attempt for admin email: {admin.email}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный логин или пароль"
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": db_admin.email}, expires_delta=access_token_expires
    )
    await log_admin_activity(db, db_admin.id, request, action="login")
    logger.info(f"Admin logged in successfully: {db_admin.email}")
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=AdminResponse)
@rate_limit("access_me_admin")  # Лимит определяется в constants.py
async def read_admins_me(
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    db: AsyncSession = Depends(get_async_db),
    request: Request = None
):
    """Получение данных текущего администратора (защищенный эндпоинт)."""
    token = credentials.credentials
    current_admin = await get_current_admin(token, db)
    await log_admin_activity(db, current_admin.id, request, action="access_me")
    logger.info(f"Admin accessed their profile: {current_admin.email}")
    return current_admin

@router.get("/verify_token")
@rate_limit("verify_token_admin")  # Отдельный лимит с более высоким порогом
async def verify_token(
    request: Request,
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    db: AsyncSession = Depends(get_async_db)
):
    """
    Облегченная проверка действительности токена без полной загрузки профиля.
    Используется для клиентской авторизации с меньшими ограничениями по частоте запросов.
    """
    try:
        token = credentials.credentials
        current_admin = await get_current_admin(token, db)
        return {
            "is_valid": True,
            "admin_id": current_admin.id,
            "email": current_admin.email
        }
    except HTTPException:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
================
File: backend\api\admin_edit_routers.py
from enum import Enum
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from backend.schemas_enums.schemas import EventCreate, EventUpdate, TicketTypeCreate
from backend.database.user_db import AsyncSession, get_async_db, Event, TicketType
from backend.config.auth import get_current_admin, log_admin_activity
from backend.config.logging_config import logger
from sqlalchemy.sql import func
from sqlalchemy.orm import selectinload
from sqlalchemy.future import select

router = APIRouter()
bearer_scheme = HTTPBearer()

# Маршрут для получения списка всех мероприятий (для администраторов)
@router.get("/events", response_model=list[EventCreate])
async def get_admin_events(
    db: AsyncSession = Depends(get_async_db),
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    request: Request = None
):
    """
    Получение списка всех мероприятий (включая черновики) для администраторов.
    """
    try:
        token = credentials.credentials
        current_admin = await get_current_admin(token, db)

        # Получаем все мероприятия, включая черновики
        result = await db.execute(
            select(Event).options(selectinload(Event.tickets))
        )
        events = result.scalars().all()

        event_responses = []
        for event in events:
            event_dict = event.__dict__
            if event.tickets:
                ticket = event.tickets[0]
                event_dict["ticket_type"] = TicketTypeCreate(
                    name=ticket.name,
                    price=ticket.price,
                    available_quantity=ticket.available_quantity,
                    free_registration=ticket.free_registration
                ).model_dump()
            event_responses.append(EventCreate(**event_dict))

        await log_admin_activity(db, current_admin.id, request, action="get_events")
        logger.info(f"Admin {current_admin.email} retrieved all events")
        return event_responses
    except HTTPException as e:
        logger.error(f"Unauthorized access to /admin_edits/events: {str(e)}")
        raise e
    except Exception as e:
        logger.error(f"Error retrieving events for admin: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve events"
        )

# Маршрут для создания мероприятия
@router.post("", response_model=EventCreate, status_code=status.HTTP_201_CREATED)
async def create_event(
    event: EventCreate,
    db: AsyncSession = Depends(get_async_db),
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    request: Request = None
):
    try:
        token = credentials.credentials
        current_admin = await get_current_admin(token, db)
        
        # Получаем текущее время из базы данных
        result = await db.execute(select(func.now()))
        now_without_tz = result.scalar()
        
        db_event = Event(
            title=event.title,
            description=event.description,
            start_date=event.start_date.replace(tzinfo=None) if event.start_date.tzinfo else event.start_date,
            end_date=event.end_date.replace(tzinfo=None) if event.end_date and event.end_date.tzinfo else event.end_date,
            location=event.location,
            image_url=event.image_url,
            price=event.price,
            published=event.published,
            created_at=now_without_tz,
            updated_at=now_without_tz,
            status=event.status
        )
        db.add(db_event)
        await db.flush()
        
        if event.ticket_type:
            ticket_type = TicketType(
                event_id=db_event.id,
                name=event.ticket_type.name.value,
                price=event.ticket_type.price,
                available_quantity=event.ticket_type.available_quantity,
                sold_quantity=0,
                free_registration=event.ticket_type.free_registration
            )
            db.add(ticket_type)
            await db.flush()

        await db.commit()

        # Повторно получаем объект с подгрузкой связанных данных
        db_event = await db.get(Event, db_event.id, options=[selectinload(Event.tickets)])
        
        event_dict = db_event.__dict__
        if db_event.tickets:
            ticket = db_event.tickets[0]
            event_dict["ticket_type"] = TicketTypeCreate(
                name=ticket.name,
                price=ticket.price,
                available_quantity=ticket.available_quantity,
                free_registration=ticket.free_registration
            ).model_dump()
        
        await log_admin_activity(db, current_admin.id, request, action="create_event")
        logger.info(f"Event created by admin {current_admin.email}: {db_event.title}")
        return EventCreate(**event_dict)
    except HTTPException as e:
        logger.error(f"Validation error creating event: {str(e.detail)}")
        raise e
    except Exception as e:
        logger.error(f"Error creating event: {str(e)}")
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create event: {str(e)}"
        )

# Маршрут для обновления мероприятия
@router.put("/{event_id}", response_model=EventCreate)
async def update_event(
    event_id: int,
    event: EventUpdate,
    db: AsyncSession = Depends(get_async_db),
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    request: Request = None
):
    token = credentials.credentials
    current_admin = await get_current_admin(token, db)
    
    db_event = await db.get(Event, event_id)
    if not db_event:
        raise HTTPException(status_code=404, detail="Event not found")

    update_data = event.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        if key == "status":
            value = value.value if isinstance(value, Enum) else value
        setattr(db_event, key, value)
    
    # Получаем текущее время из базы данных
    result = await db.execute(select(func.now()))
    now_without_tz = result.scalar()
    db_event.updated_at = now_without_tz

    await db.commit()

    # Повторно получаем объект с подгрузкой связанных данных
    db_event = await db.get(Event, db_event.id, options=[selectinload(Event.tickets)])

    event_dict = db_event.__dict__
    if db_event.tickets:
        ticket = db_event.tickets[0]
        event_dict["ticket_type"] = TicketTypeCreate(
            name=ticket.name,
            price=ticket.price,
            available_quantity=ticket.available_quantity,
            free_registration=ticket.free_registration
        ).model_dump()

    await log_admin_activity(db, current_admin.id, request, action="update_event")
    logger.info(f"Event updated by admin {current_admin.email}: {db_event.title}")
    return EventCreate(**event_dict)
================
File: backend\api\event_routers.py
from fastapi import APIRouter, Depends, HTTPException, status, Request
from backend.database.user_db import AsyncSession, get_async_db, Event
from backend.config.logging_config import logger
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from backend.schemas_enums.schemas import EventCreate, TicketTypeCreate

router = APIRouter(
    tags=["Events"]
)

# Маршрут для получения списка мероприятий (без авторизации)
@router.get("", response_model=list[EventCreate])
async def get_events(db: AsyncSession = Depends(get_async_db)):
    result = await db.execute(
        select(Event).where(Event.status != "draft").options(selectinload(Event.tickets))
    )
    events = result.scalars().all()
    
    event_responses = []
    for event in events:
        event_dict = event.__dict__
        if event.tickets:
            ticket = event.tickets[0]
            event_dict["ticket_type"] = TicketTypeCreate(
                name=ticket.name,
                price=ticket.price,
                available_quantity=ticket.available_quantity,
                free_registration=ticket.free_registration
            ).model_dump()
        event_responses.append(EventCreate(**event_dict))
    
    return event_responses

# Маршрут для получения конкретного мероприятия (без авторизации)
@router.get("/{event_id}", response_model=EventCreate)
async def get_event(
    event_id: int,
    db: AsyncSession = Depends(get_async_db),
    request: Request = None
):
    """Получение конкретного мероприятия по ID (публичный доступ)."""
    try:
        # Подгружаем событие с связанными tickets
        db_event = await db.get(Event, event_id, options=[selectinload(Event.tickets)])
        if not db_event:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Event not found")
        
        # Формируем ответ с ticket_type
        event_dict = db_event.__dict__
        if db_event.tickets and len(db_event.tickets) > 0:
            ticket = db_event.tickets[0]  # Берем первый тип билета
            event_dict["ticket_type"] = TicketTypeCreate(
                name=ticket.name,
                price=ticket.price,
                available_quantity=ticket.available_quantity,
                free_registration=ticket.free_registration
            ).model_dump()
            logger.info(f"Event {event_id} retrieved with {ticket.available_quantity - ticket.sold_quantity} available tickets")
        
        logger.info(f"Public request for event {event_id}")
        return EventCreate(**event_dict)
    except Exception as e:
        logger.error(f"Error retrieving event {event_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve event"
        )
================
File: backend\api\guests_registration_routers.py
# backend/api/guests_registration_routers.py
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status
from backend.database.user_db import AsyncSession, Event, get_async_db, Registration, TicketType
from backend.config.auth import get_current_user
from sqlalchemy.future import select

router = APIRouter(tags=["Registration"])

@router.post("/register")
async def register_for_event(
    data: dict,
    db: AsyncSession = Depends(get_async_db),
    current_user = Depends(get_current_user)
):
    event_id = data.get("event_id")
    user_id = data.get("user_id")

    if not event_id or not user_id:
        raise HTTPException(status_code=400, detail="Event ID and User ID are required")

    # Проверка статуса мероприятия
    event = await db.get(Event, event_id)
    if not event or event.status != "registration_open":
        raise HTTPException(status_code=400, detail="Registration is not open for this event")

    # Проверка доступных билетов
    ticket = (await db.execute(select(TicketType).where(TicketType.event_id == event_id))).scalars().first()
    if not ticket or ticket.available_quantity <= ticket.sold_quantity:
        raise HTTPException(status_code=400, detail="No available tickets")

    # Создание записи о регистрации
    registration = Registration(
        user_id=user_id,
        event_id=event_id,
        ticket_type_id=ticket.id,
        ticket_number=f"TICKET-{event_id}-{user_id}-{datetime.utcnow().timestamp()}",
        payment_status=False,
        amount_paid=0 if ticket.free_registration else ticket.price,
    )
    db.add(registration)
    ticket.sold_quantity += 1
    await db.commit()

    return {"message": "Successfully registered"}
================
File: backend\api\media_routers.py

================
File: backend\api\user_auth_routers.py
from fastapi import APIRouter, Depends, HTTPException, status, Request
from backend.schemas_enums.schemas import UserCreate, UserLogin, UserResponse
from backend.config.auth import create_user, get_user_by_username, pwd_context, create_access_token, get_current_user, log_user_activity
from backend.database.user_db import AsyncSession, get_async_db
from backend.config.logging_config import logger
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from datetime import timedelta
from backend.config.rate_limiter import rate_limit
from constants import ACCESS_TOKEN_EXPIRE_MINUTES

router = APIRouter()

bearer_scheme = HTTPBearer()

@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
@rate_limit("register")  # Лимит определяется в constants.py
async def register_user(user: UserCreate, db: AsyncSession = Depends(get_async_db), request: Request = None):
    """Регистрация нового пользователя."""
    existing_user = await get_user_by_username(db, user.email)
    if existing_user:
        logger.warning(f"Attempt to register existing email: {user.email}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already exists"
        )
    
    try:
        new_user = await create_user(db, user.fio, user.email, user.password, user.telegram, user.whatsapp)
        await log_user_activity(db, new_user.id, request, action="register")
        logger.info(f"User registered successfully: {new_user.email}")
        return new_user
    except Exception as e:
        logger.error(f"Error registering user: {str(e)}")
        await db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to register user"
        )

@router.post("/login")
@rate_limit("login")  # Лимит определяется в constants.py
async def login_user(user: UserLogin, db: AsyncSession = Depends(get_async_db), request: Request = None):
    """Авторизация пользователя с возвратом токена."""
    db_user = await get_user_by_username(db, user.email)
    if not db_user or not pwd_context.verify(user.password, db_user.password_hash):
        await log_user_activity(db, db_user.id if db_user else None, request, action="login_failed")
        logger.warning(f"Failed login attempt for email: {user.email}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Неверный логин или пароль"
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": db_user.email}, expires_delta=access_token_expires
    )
    await log_user_activity(db, db_user.id, request, action="login")
    logger.info(f"User logged in successfully: {db_user.email}")
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserResponse)
@rate_limit("access_me")  # Лимит определяется в constants.py
async def read_users_me(
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    db: AsyncSession = Depends(get_async_db),
    request: Request = None
):
    """Получение данных текущего пользователя (защищенный эндпоинт)."""
    token = credentials.credentials
    current_user = await get_current_user(token, db)
    await log_user_activity(db, current_user.id, request, action="access_me")
    logger.info(f"User accessed their profile: {current_user.email}")
    return current_user

@router.get("/verify_token")
@rate_limit("verify_token")  # Отдельный лимит с более высоким порогом
async def verify_token(
    request: Request,
    credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme),
    db: AsyncSession = Depends(get_async_db)
):
    """
    Облегченная проверка действительности токена без полной загрузки профиля.
    Используется для клиентской авторизации с меньшими ограничениями по частоте запросов.
    """
    try:
        token = credentials.credentials
        # Только проверяем действительность токена без загрузки полного профиля
        current_user = await get_current_user(token, db)
        return {
            "is_valid": True,
            "user_id": current_user.id,
            "email": current_user.email
        }
    except HTTPException:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
================
File: backend\config\auth.py
import hashlib
from sqlalchemy.ext.asyncio import AsyncSession
from backend.database.user_db import User, UserActivity, Admin, get_async_db
from sqlalchemy.future import select
from sqlalchemy.sql import func, text
from passlib.context import CryptContext
from typing import Optional
from authlib.jose import jwt
from authlib.jose.errors import JoseError
from datetime import timedelta
from fastapi import HTTPException, Request, status
from backend.config.logging_config import logger
from constants import SECRET_KEY, ALGORITHM

# Контекст для хэширования паролей
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

async def create_user(session: AsyncSession, fio: str, email: str, password: str, telegram: str, whatsapp: str) -> User:
    """Создание нового пользователя с хэшированием пароля."""
    # Получаем текущее время из базы данных
    result = await session.execute(select(func.now()))
    now = result.scalar()

    password_hash = pwd_context.hash(password)
    new_user = User(
        fio=fio,
        email=email,
        password_hash=password_hash,
        telegram=telegram,
        whatsapp=whatsapp,
        created_at=now,
        updated_at=now
    )
    session.add(new_user)
    await session.commit()
    await session.refresh(new_user)
    return new_user

async def get_user_by_username(session: AsyncSession, email: str) -> Optional[User]:
    """Получение пользователя по email."""
    result = await session.execute(select(User).where(User.email == email))
    return result.scalars().first()

async def create_access_token(data: dict, expires_delta: timedelta = None):
    """Генерация JWT-токена."""
    to_encode = data.copy()
    
    # Получаем текущее время из базы данных
    async with get_async_db() as session:
        result = await session.execute(select(func.now()))
        now = result.scalar()

    if expires_delta:
        expire = now + expires_delta
    else:
        expire = now + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str, session: AsyncSession) -> User:
    """Проверка токена и получение текущего пользователя."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        # Декодируем токен с помощью authlib
        payload = jwt.decode(token, SECRET_KEY)
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JoseError as e:
        logger.error(f"JWT decode error: {str(e)}")
        raise credentials_exception
    
    user = await get_user_by_username(session, email)
    if user is None:
        raise credentials_exception
    return user

async def create_admin(session: AsyncSession, fio: str, email: str, password: str) -> Admin:
    """Создание нового администратора с хэшированием пароля."""
    # Получаем текущее время из базы данных
    result = await session.execute(select(func.now()))
    now = result.scalar()

    password_hash = pwd_context.hash(password)
    new_admin = Admin(
        fio=fio,
        email=email,
        password_hash=password_hash,
        created_at=now,
        updated_at=now
    )
    session.add(new_admin)
    await session.commit()
    await session.refresh(new_admin)
    return new_admin

async def get_admin_by_username(session: AsyncSession, email: str) -> Optional[Admin]:
    """Получение администратора по email."""
    result = await session.execute(select(Admin).where(Admin.email == email))
    return result.scalars().first()

async def get_current_admin(token: str, session: AsyncSession) -> Admin:
    """Проверка токена и получение текущего администратора."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        # Декодируем токен с помощью authlib
        payload = jwt.decode(token, SECRET_KEY)
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JoseError as e:
        logger.error(f"JWT decode error: {str(e)}")
        raise credentials_exception
    
    # Получаем администратора по email
    result = await session.execute(select(Admin).where(Admin.email == email))
    admin = result.scalars().first()
    if admin is None:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized as an admin"
        )
    return admin

async def log_user_activity(
    db: AsyncSession,
    user_id: int,
    request: Request,
    action: str
):
    """Логирование активности пользователя с фингерпринтом устройства, предотвращение дубликатов."""
    try:
        # Получаем IP-адрес из заголовка X-Forwarded-For (для прокси) или напрямую
        ip_address = request.headers.get("X-Forwarded-For", request.client.host)
        # Получаем куки (если они есть)
        cookies = "; ".join([f"{key}={value}" for key, value in request.cookies.items()]) if request.cookies else None
        # Получаем User-Agent
        user_agent = request.headers.get("User-Agent", "Unknown")
        # Дополнительные заголовки для фингерпринта
        accept_language = request.headers.get("Accept-Language", "")
        accept_encoding = request.headers.get("Accept-Encoding", "")

        # Генерируем фингерпринт устройства
        fingerprint_data = f"{ip_address}{user_agent}{cookies or ''}{accept_language}{accept_encoding}"
        device_fingerprint = hashlib.sha256(fingerprint_data.encode("utf-8")).hexdigest()

        # Получаем текущее время из базы данных
        result = await db.execute(select(func.now()))
        now = result.scalar()

        # Проверяем существование записи с теми же данными за последние 5 минут
        stmt = select(UserActivity).where(
            UserActivity.user_id == user_id,
            UserActivity.ip_address == ip_address,
            UserActivity.device_fingerprint == device_fingerprint,
            UserActivity.action == action,
            UserActivity.created_at >= func.now() - text("INTERVAL '5 minutes'")
        )
        result = await db.execute(stmt)
        existing_activity = result.scalars().first()

        if not existing_activity:
            # Если записи нет, создаем новую
            activity = UserActivity(
                user_id=user_id,
                ip_address=ip_address,
                cookies=cookies,
                user_agent=user_agent,
                action=action,
                created_at=now.replace(tzinfo=None),  # Удаляем временную зону
                device_fingerprint=device_fingerprint
            )
            db.add(activity)
            await db.commit()
        else:
            # Если запись существует, обновляем created_at
            existing_activity.created_at = now.replace(tzinfo=None)
            await db.commit()
            logger.info(f"Duplicate activity ignored for user_id={user_id}, action={action}")
    except Exception as e:
        logger.error(f"Error logging user activity: {str(e)}")
        await db.rollback()
        raise

async def log_admin_activity(
    db: AsyncSession,
    admin_id: int,
    request: Request,
    action: str
):
    """Логирование активности администратора."""
    try:
        # Получаем IP-адрес из заголовка X-Forwarded-For (для прокси) или напрямую
        ip_address = request.headers.get("X-Forwarded-For", request.client.host)
        # Получаем куки (если они есть)
        cookies = "; ".join([f"{key}={value}" for key, value in request.cookies.items()]) if request.cookies else None
        # Получаем User-Agent
        user_agent = request.headers.get("User-Agent", "Unknown")
        # Дополнительные заголовки для фингерпринта
        accept_language = request.headers.get("Accept-Language", "")
        accept_encoding = request.headers.get("Accept-Encoding", "")

        # Генерируем фингерпринт устройства
        fingerprint_data = f"{ip_address}{user_agent}{cookies or ''}{accept_language}{accept_encoding}"
        device_fingerprint = hashlib.sha256(fingerprint_data.encode("utf-8")).hexdigest()

        # Получаем текущее время из базы данных
        result = await db.execute(select(func.now()))
        now = result.scalar()

        # Проверяем существование записи с теми же данными за последние 5 минут
        stmt = select(UserActivity).where(
            UserActivity.user_id == admin_id,
            UserActivity.ip_address == ip_address,
            UserActivity.device_fingerprint == device_fingerprint,
            UserActivity.action == action,
            UserActivity.created_at >= func.now() - text("INTERVAL '5 minutes'")
        )
        result = await db.execute(stmt)
        existing_activity = result.scalars().first()

        if not existing_activity:
            # Если записи нет, создаем новую
            activity = UserActivity(
                user_id=admin_id,
                ip_address=ip_address,
                cookies=cookies,
                user_agent=user_agent,
                action=action,
                created_at=now.replace(tzinfo=None),  # Удаляем временную зону
                device_fingerprint=device_fingerprint
            )
            db.add(activity)
            await db.commit()
        else:
            # Если запись существует, обновляем created_at
            existing_activity.created_at = now.replace(tzinfo=None)
            await db.commit()
            logger.info(f"Duplicate admin activity ignored for admin_id={admin_id}, action={action}")
    except Exception as e:
        logger.error(f"Error logging admin activity: {str(e)}")
        await db.rollback()
        raise

async def get_user_or_ip_key(request: Request) -> str:
    """Возвращает user_id (если аутентифицирован) или IP-адрес как ключ для ограничения."""
    auth_header = request.headers.get("Authorization")
    if auth_header and auth_header.startswith("Bearer "):
        token = auth_header.split(" ")[1]
        async with get_async_db() as session:
            try:
                user = await get_current_user(token, session)
                return f"user_{user.id}"  # Ключ на основе user_id
            except Exception:
                pass
    return f"ip_{request.client.host}"  # Ключ на основе IP для неаутентифицированных пользователей
================
File: backend\config\logging_config.py
# config/logging_config.py
import logging
from logging.handlers import RotatingFileHandler


def setup_logging():
    """Настройка логирования для приложения."""
    # Создание логгера root для перехвата всех логов
    logger = logging.getLogger()  # root logger вместо "JE"
    logger.setLevel(logging.INFO)  # Уровень логирования

    # Проверка, есть ли уже обработчики, чтобы избежать дублирования
    if not logger.handlers:
        # Обработчик для консоли
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)

        # Обработчик для файла с ротацией
        file_handler = RotatingFileHandler("app.log", maxBytes=10**6, backupCount=3)
        file_handler.setLevel(logging.ERROR)  # Логировать только ошибки в файл

        # Форматтер
        formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
        console_handler.setFormatter(formatter)
        file_handler.setFormatter(formatter)

        # Добавление обработчиков к логгеру
        logger.addHandler(console_handler)
        logger.addHandler(file_handler)

    return logger

# Инициализация логирования при импорте этого модуля
logger = setup_logging()
================
File: backend\config\rate_limiter.py
from slowapi import Limiter
from slowapi.util import get_remote_address
from constants import RATE_LIMITS
from functools import wraps
from fastapi import Request
from typing import Callable, Any

# Инициализация Limiter
limiter = Limiter(key_func=get_remote_address)

def rate_limit(action: str):
    """
    Декоратор для применения лимитов запросов на основе действия (action).
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args: Any, **kwargs: Any) -> Any:
            # Получаем лимит из RATE_LIMITS или устанавливаем значение по умолчанию
            limit = RATE_LIMITS.get(action, "100/minute")  # По умолчанию 100 запросов в минуту
            
            # Находим объект Request в аргументах
            request = None
            for arg in args:
                if isinstance(arg, Request):
                    request = arg
                    break
            
            if 'request' in kwargs:
                request = kwargs['request']
            
            if not request:
                # Если request не найден в аргументах, создаем заглушку
                # или используем другие методы для получения информации о запросе
                from starlette.datastructures import Headers
                from starlette.types import Scope
                
                # Создаем минимальную заглушку для Request
                class RequestStub(Request):
                    def __init__(self):
                        self.scope = {"type": "http", "headers": []}
                        self.headers = Headers(raw=self.scope.get("headers", []))
                        self.client = type('obj', (object,), {'host': '127.0.0.1'})
                
                request = RequestStub()
            
            # Применяем лимит с использованием request
            @limiter.limit(limit)
            async def limited_func(request: Request) -> Any:
                # Передаем все оригинальные аргументы в функцию
                return await func(*args, **kwargs)
            
            return await limited_func(request)
        
        return wrapper
    
    return decorator
================
File: backend\database\admin_db.py

================
File: backend\database\drop_db.py
# backend/database/drop_db.py
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from backend.database.user_db import Base  # Импортируем Base
from constants import DATABASE_URL

# Создаем асинхронный движок
engine = create_async_engine(DATABASE_URL, echo=True, future=True)

async def drop_tables():
    async with engine.begin() as conn:
        # Отражаем текущую структуру базы через run_sync
        await conn.run_sync(Base.metadata.reflect)
        # Удаляем все таблицы через run_sync
        await conn.run_sync(Base.metadata.drop_all)

if __name__ == "__main__":
    asyncio.run(drop_tables())
    print("Все таблицы успешно удалены.")
================
File: backend\database\init_admin_db.py

================
File: backend\database\init_user_db.py

================
File: backend\database\user_db.py
import asyncio
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from backend.schemas_enums.enums import EventStatus, MediaType, Status
from constants import DATABASE_URL
from datetime import datetime
from sqlalchemy.orm import (
    declarative_base,
    relationship,
    backref,
    selectinload
)
from contextlib import asynccontextmanager
from sqlalchemy import (
    Column,
    Integer,
    String,
    ForeignKey,
    Boolean,
    Text,
    DECIMAL,
    TIMESTAMP,
    Enum,
    UniqueConstraint,
)

# Создание асинхронного движка SQLAlchemy
engine = create_async_engine(DATABASE_URL, echo=True, future=True)

# Базовый класс для моделей
Base = declarative_base()

# Создание асинхронной фабрики сессий
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False
)


class UserParams(Base):
    __tablename__ = "users_params"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    max_card_amount = Column(DECIMAL(20, 8), nullable=False)
    max_photo_program_amount = Column(DECIMAL(20, 8), nullable=False)
    max_video_program_amount = Column(DECIMAL(20, 8), nullable=False)
    
    # Обратная ссылка на пользователя
    user = relationship("User", back_populates="params")


class Event(Base):
    __tablename__ = "events"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(255), nullable=False)
    description = Column(Text)
    start_date = Column(TIMESTAMP, nullable=False)
    end_date = Column(TIMESTAMP)
    location = Column(String(255))
    image_url = Column(String(255))
    price = Column(DECIMAL(20, 8), nullable=False)
    published = Column(Boolean, default=False)
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    updated_at = Column(TIMESTAMP, default=datetime.utcnow, onupdate=datetime.utcnow)
    status = Column(Enum(EventStatus), default=EventStatus.draft, nullable=False)
    
    # Связь с типами билетов
    tickets = relationship("TicketType", back_populates="event")
    
    # Связь с регистрациями на мероприятие
    registrations = relationship("Registration", back_populates="event")
    
    # Связь с медиа, относящимся к мероприятию
    medias = relationship("Media", back_populates="event")


class TicketType(Base):
    __tablename__ = "ticket_types"

    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"))
    name = Column(String(255), nullable=False)  # Название типа билета (например, "Стандарт", "Премиум")
    price = Column(DECIMAL(20, 8), nullable=False)  # Цена билета
    available_quantity = Column(Integer, nullable=False)  # Количество доступных билетов данного типа
    sold_quantity = Column(Integer, default=0)  # Количество проданных билетов данного типа
    free_registration = Column(Boolean, default=False)  # Возможность бесплатной регистрации
    
    # Обратная связь с событием
    event = relationship("Event", back_populates="tickets")
    
    # Связь с регистрациями, использующими данный тип билета
    registrations = relationship("Registration", back_populates="ticket_type")


class Registration(Base):
    __tablename__ = "registrations"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    event_id = Column(Integer, ForeignKey("events.id"))
    ticket_type_id = Column(Integer, ForeignKey("ticket_types.id"))
    ticket_number = Column(String(255))  # Номер билета
    payment_status = Column(Boolean, default=False)  # Статус оплаты
    amount_paid = Column(DECIMAL(20, 8))  # Сумма платежа
    status = Column(Enum(Status), default=Status.pending.name)  # Статусы: pending, approved, rejected
    submission_time = Column(TIMESTAMP, default=datetime.utcnow)
    
    # Обратная связь с пользователем
    user = relationship("User", back_populates="registrations")
    
    # Обратная связь с мероприятием
    event = relationship("Event", back_populates="registrations")
    
    # Обратная связь с типом билета
    ticket_type = relationship("TicketType", back_populates="registrations")


class Media(Base):
    __tablename__ = "medias"

    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(Integer, ForeignKey("events.id"))  # К какому мероприятию относится
    user_uploaded_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)  # Кто загрузил (обычный пользователь)
    admin_uploaded_by_id = Column(Integer, ForeignKey("admins.id"), nullable=True)  # Кто загрузил (администратор)
    type = Column(Enum(MediaType), nullable=False)  # Тип медиафайла
    url = Column(String(255), nullable=False)  # Ссылка на файл
    caption = Column(String(500))  # Описание файла
    approved = Column(Boolean, default=False)  # Прошёл ли модерацию
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    updated_at = Column(TIMESTAMP, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Обратная связь с мероприятием
    event = relationship("Event", back_populates="medias")
    
    # Обратная связь с пользователем, загрузившим медиа
    user_uploaded_by = relationship("User", foreign_keys=[user_uploaded_by_id], back_populates="user_medias")
    
    # Обратная связь с администратором, загрузившим медиа
    admin_uploaded_by = relationship("Admin", foreign_keys=[admin_uploaded_by_id], back_populates="admin_medias")
    
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    fio = Column(String(255), nullable=False)
    email = Column(String(255), unique=True, nullable=False)
    password_hash = Column(Text, nullable=False)
    avatar_url = Column(String(255), nullable=True)
    telegram = Column(String(255), unique=True, nullable=False)
    whatsapp = Column(String(255), unique=True, nullable=False)
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    updated_at = Column(TIMESTAMP, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Связь с параметрами пользователя
    params = relationship("UserParams", uselist=False, back_populates="user")
    # Связь с регистрациями пользователя
    registrations = relationship("Registration", back_populates="user")
    # Связь с медиа, загруженным пользователем
    user_medias = relationship("Media", foreign_keys=[Media.user_uploaded_by_id], back_populates="user_uploaded_by")
    activities = relationship("UserActivity", back_populates="user")  # Новая связь
    
class UserActivity(Base):
    __tablename__ = "user_activities"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    ip_address = Column(String(45), nullable=False)  # Поддержка IPv4 и IPv6
    cookies = Column(Text, nullable=True)  # Храним куки как текст
    user_agent = Column(Text, nullable=True)  # Информация о браузере/устройстве
    action = Column(String(50), nullable=False)  # Тип действия: register, login, access_me
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    device_fingerprint = Column(Text, nullable=True)

    user = relationship("User", back_populates="activities")
    
    # Уникальный индекс для предотвращения дубликатов
    __table_args__ = (
        UniqueConstraint('user_id', 'ip_address', 'device_fingerprint', 'action', 'created_at', name='uq_user_activity'),
    )


class Admin(Base):
    __tablename__ = "admins"

    id = Column(Integer, primary_key=True, index=True)
    fio = Column(String(255), nullable=False)
    email = Column(String(255), unique=True, nullable=False)
    password_hash = Column(Text, nullable=False)
    avatar_url = Column(String(255), nullable=True)
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    updated_at = Column(TIMESTAMP, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Связь с медиа, загруженным администратором
    admin_medias = relationship("Media", foreign_keys=[Media.admin_uploaded_by_id], back_populates="admin_uploaded_by")

# Функция для инициализации базы данных
async def init_db():
    try:
        async with engine.begin() as conn:
            # Создание всех таблиц
            await conn.run_sync(Base.metadata.create_all)
            print("Таблицы успешно созданы.")
    except Exception as e:
        print(f"Произошла ошибка при инициализации базы данных: {e}")
    finally:
        await engine.dispose()

# Контекст-менеджер для получения сессии
@asynccontextmanager
async def get_session() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        async with session.begin():
            try:
                yield session
            except Exception:
                await session.rollback()
                raise
            finally:
                await session.close()

# Dependency для FastAPI
async def get_async_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise

if __name__ == "__main__":
    asyncio.run(init_db())
================
File: backend\schemas_enums\enums.py
# backend/schemas_enums/enums.py
from enum import Enum

class MediaType(Enum):
    photo = 'photo'
    video = 'video'

class Status(Enum):
    pending = 'pending'
    approved = 'approved'
    rejected = 'rejected'

class Role(Enum):
    user = 'user'
    admin = 'admin'

class TicketTypeEnum(Enum):  # Новый enum для типов билетов
    free = 'free'
    standart = 'standart'
    vip = 'vip'
    org = 'org'
    
class EventStatus(Enum):
    draft = 'draft'
    registration_open = 'registration_open'
    registration_closed = 'registration_closed'
    completed = 'completed'
================
File: backend\schemas_enums\schemas.py
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, EmailStr

from backend.schemas_enums.enums import EventStatus, TicketTypeEnum


#------------------------
# ADMINS
#------------------------

class AdminCreate(BaseModel):
    fio: str
    email: EmailStr
    password: str

class AdminLogin(BaseModel):
    email: EmailStr
    password: str

class AdminResponse(BaseModel):
    id: int
    fio: str
    email: EmailStr

    class Config:
        from_attributes = True  # Для совместимости с SQLAlchemy
        
#------------------------
# USERS
#------------------------   
    

class UserCreate(BaseModel):
    fio: str
    email: EmailStr
    password: str
    telegram: str
    whatsapp: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    id: int
    fio: str
    email: EmailStr
    telegram: str
    whatsapp: str

    class Config:
        from_attributes = True  # Для совместимости с SQLAlchemy
        
        
#------------------------
# EVENTS
#------------------------

class TicketTypeCreate(BaseModel):
    name: TicketTypeEnum  # Заменяем str на TicketTypeEnum
    price: float  # Цена билета
    available_quantity: int  # Доступное количество
    free_registration: Optional[bool] = False  # Бесплатная регистрация (по умолчанию False)

    class Config:
        from_attributes = True

class EventCreate(BaseModel):
    title: str
    description: Optional[str] = None
    start_date: datetime
    end_date: Optional[datetime] = None
    location: Optional[str] = None
    image_url: Optional[str] = None
    price: float
    published: Optional[bool] = False
    created_at: datetime
    updated_at: datetime
    status: Optional[EventStatus] = EventStatus.draft  # По умолчанию 'draft'
    ticket_type: Optional[TicketTypeCreate] = None

    class Config:
        from_attributes = True
    
    
class EventUpdate(BaseModel):
    id: Optional[int] = None
    title: Optional[str] = None
    description: Optional[str] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    location: Optional[str] = None
    image_url: Optional[str] = None
    price: Optional[float] = None
    published: Optional[bool] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    status: Optional[EventStatus] = None  # Позволяем обновлять статус

    class Config:
        from_attributes = True
        

================
File: frontend\src\app\globals.css
/* frontend/src/app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Root variables for theming */
:root {
  --background: #ffffff;
  --foreground: #171717;
  
  /* Orange theme colors */
  --primary: #f97316;
  --primary-hover: #ea580c;
  --primary-light: #ffedd5;
  
  /* UI colors */
  --success: #22c55e;
  --warning: #f59e0b;
  --error: #ef4444;
  --info: #3b82f6;
}

/* Dark mode variables */
@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: var(--font-geist-sans), Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Input styles */
input, button, a, select, textarea {
  outline: none;
  transition: all 500ms cubic-bezier(0.25, 0.1, 0.25, 1);
  backface-visibility: hidden;
  transform-style: preserve-3d;
  will-change: transform, opacity;
}

/* Placeholder styles */
::placeholder {
  transition: opacity 500ms ease, color 500ms ease;
}

input:focus::placeholder {
  opacity: 0.7;
}

/* Base styles */
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

/* Animation keyframes */
@keyframes slideDown {
  from { transform: translateY(-100%); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(0.95); }
}

/* Animation utility classes */
.animate-slide-down { animation: slideDown 0.3s ease-out; }
.animate-fade-in { animation: fadeIn 0.25s ease-in-out; }
.animate-fade-out { animation: fadeOut 0.25s ease-in-out; }
.animate-spin { animation: spin 1s linear infinite; }
.animate-spin-slow { animation: spin 2s linear infinite; }
.animate-pulse { animation: pulse 1.5s ease-in-out infinite; }

/* Common layout utilities */
.full-screen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

.center {
  display: flex;
  align-items: center;
  justify-content: center;
}

.backdrop {
  background-color: rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(8px);
}

/* Fix for iOS safari scrolling/hiding */
body.no-scroll {
  position: fixed;
  width: 100%;
  overflow-y: hidden;
}

/* Custom component styles */
@layer components {
  .btn {
    @apply px-4 py-2 rounded-lg transition-all duration-300 font-medium;
  }
  
  .btn-primary {
    @apply bg-orange-500 text-white hover:bg-orange-600 active:bg-orange-700;
  }
  
  .btn-secondary {
    @apply bg-white border border-orange-500 text-orange-500 hover:bg-orange-50;
  }
  
  .card {
    @apply bg-white rounded-xl shadow-md hover:shadow-xl transition-all duration-300;
  }
  
  .form-input {
    @apply w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent;
  }
}
================
File: frontend\src\app\layout.tsx
// frontend/src/app/layout.tsx
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { AuthProvider } from "@/contexts/AuthContext";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata = {
  title: "Moscow Mellows",
  description: "Moscow Mellows - ваша платформа для мероприятий",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ru" suppressHydrationWarning>
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        <AuthProvider>
          {/* Не включаем Header, так как он будет добавлен в соответствующих макетах */}
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}
================
File: frontend\src\app\page.module.css
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}

================
File: frontend\src\app\page.tsx
// frontend/src/app/page.tsx
"use client";

import React, { useState, useEffect } from "react";
import Link from "next/link";
import Loading from "@/components/Loading";
import Footer from "@/components/Footer";
import { motion } from "framer-motion";
import { FaUser, FaCalendarAlt, FaVideo, FaArrowRight } from "react-icons/fa";
import { IconType } from "react-icons";

interface FeatureCardProps {
  href: string;
  icon: IconType;
  title: string;
  description: string;
  ctaText: string;
}

const FeatureCard: React.FC<FeatureCardProps> = ({ href, icon: Icon, title, description, ctaText }) => (
  <Link href={href} className="group">
    <div className="bg-white rounded-xl p-6 shadow-md hover:shadow-xl transition-all duration-300 transform group-hover:-translate-y-1 h-full flex flex-col">
      <div className="w-14 h-14 bg-orange-100 rounded-full flex items-center justify-center mb-5">
        <Icon className="w-8 h-8 text-orange-500" />
      </div>
      <h3 className="text-xl font-bold mb-4">{title}</h3>
      <p className="text-gray-700 flex-grow">{description}</p>
      <div className="mt-4 text-orange-500 group-hover:text-orange-600 flex items-center">
        {ctaText}
        <FaArrowRight className="w-5 h-5 ml-2 transform group-hover:translate-x-1 transition-transform duration-300" />
      </div>
    </div>
  </Link>
);

const PublicHomePage: React.FC = () => {
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Убираем искусственную задержку и сразу проверяем состояние
    setLoading(false);
    document.body.style.overflow = "auto"; // Сбрасываем стиль overflow
  }, []);

  const features: FeatureCardProps[] = [
    {
      href: "/registration",
      icon: FaUser,
      title: "Регистрация",
      description: "Создайте личный кабинет на нашей платформе, чтобы открыть возможность регистрации на мероприятия.",
      ctaText: "Зарегистрироваться",
    },
    {
      href: "/events",
      icon: FaCalendarAlt,
      title: "Мероприятия",
      description: "Прошедшие и запланированные мероприятия.",
      ctaText: "Смотреть мероприятия",
    },
    {
      href: "/media",
      icon: FaVideo,
      title: "Медиа",
      description: "Фото, видео и аудио с наших мероприятий.",
      ctaText: "Смотреть медиа",
    },
  ];

  return (
    <>
      {loading ? (
        <Loading />
      ) : (
        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }}>
          <main className="flex-grow flex flex-col justify-center items-center pt-24 pb-16 px-4 min-h-[calc(100vh-120px)]">
            <h1 className="text-4xl font-bold text-center mb-12">MOSCOW MELLOWS</h1>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-6xl w-full">
              {features.map((feature, index) => (
                <FeatureCard key={index} {...feature} />
              ))}
            </div>
          </main>
          <Footer />
        </motion.div>
      )}
    </>
  );
};

export default PublicHomePage;
================
File: frontend\src\app\(admin)\layout.tsx
"use client";

import { usePathname } from "next/navigation";
import { AdminAuthProvider } from "@/contexts/AdminAuthContext";
import { ReactNode } from "react";

interface AdminLayoutProps {
  children: ReactNode;
}

export default function AdminLayout({ children }: AdminLayoutProps) {
  const pathname = usePathname();

  // Не показываем текст на странице /admin-login
  const isLoginPage = pathname === "/admin-login";

  return (
    <AdminAuthProvider>
      <div className="min-h-screen bg-gray-100">
        {!isLoginPage && (
          <p className="text-center text-red-500 py-4">
            
          </p>
        )}
        {children}
      </div>
    </AdminAuthProvider>
  );
}
================
File: frontend\src\app\(admin)\admin-login\page.tsx
"use client";
import InputField from "@/components/common/InputField";
import { ModalButton } from "@/components/common/AuthModal";
import { FaEnvelope, FaLock } from "react-icons/fa";
import { useAdminAuthForm } from "@/hooks/useAdminAuthForm";
import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { useAdminAuth } from "@/contexts/AdminAuthContext";
import AdminHeader from "@/components/AdminHeader";

export default function AdminLoginPage() {
  const router = useRouter();
  const { isAdminAuth } = useAdminAuth();
  
  // Перенаправляем уже авторизованных администраторов на страницу профиля
  useEffect(() => {
    if (isAdminAuth) {
      router.push("/admin-profile");
    }
  }, [isAdminAuth, router]);
  
  const {
    formValues,
    error,
    isLoading,
    isSuccess,
    handleChange,
    handleSubmit
  } = useAdminAuthForm({
    initialValues: {
      email: "",
      password: "",
    },
    endpoint: "/admin/login",
    redirectTo: "/admin-profile",
    isLogin: true
  });

  return (
    <>
      <AdminHeader />
      <div className="flex items-center justify-center min-h-screen bg-gray-50 pt-16">
        <div className="bg-white p-8 rounded-2xl shadow-lg border border-gray-100 w-full max-w-md">
          <h1 className="text-2xl font-bold mb-6 text-gray-900 tracking-tight">
            Вход для администраторов
          </h1>
          <form onSubmit={handleSubmit}>
            <InputField
              type="email"
              value={formValues.email}
              onChange={handleChange}
              placeholder="Email"
              icon={FaEnvelope}
              name="email"
              required
              disabled={isSuccess}
            />
            <InputField
              type="password"
              value={formValues.password}
              onChange={handleChange}
              placeholder="Пароль"
              icon={FaLock}
              name="password"
              required
              disabled={isSuccess}
            />
            {error && (
              <div className="text-red-500 bg-red-50 p-3 rounded-lg border-l-4 border-red-500 text-sm mb-6">
                {error}
              </div>
            )}
            {isSuccess && (
              <div className="text-green-600 bg-green-50 p-3 rounded-lg border-l-4 border-green-500 text-sm mb-6">
                Вход выполнен успешно! Перенаправление...
              </div>
            )}
            <ModalButton 
              type="submit" 
              disabled={isLoading || isSuccess}
            >
              {isLoading ? "Вход..." : (isSuccess ? "Успешно!" : "Войти")}
            </ModalButton>
          </form>
        </div>
      </div>
    </>
  );
}
================
File: frontend\src\app\(admin)\admin-profile\page.tsx
"use client";
import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { useAdminAuth } from "@/contexts/AdminAuthContext";
import AdminHeader from "@/components/AdminHeader";
import { FaUser, FaEnvelope, FaCalendarAlt, FaCog } from "react-icons/fa";

export default function AdminProfilePage() {
  const { adminData, isAdminAuth, isLoading, checkAdminAuth } = useAdminAuth();
  const [isInitialized, setIsInitialized] = useState(false);
  const router = useRouter();

  // Инициализация и проверка авторизации
  useEffect(() => {
    const init = async () => {
      try {
        await checkAdminAuth();
      } catch (error) {
        console.error("Ошибка при проверке авторизации:", error);
      } finally {
        setIsInitialized(true);
      }
    };
    
    init();
  }, [checkAdminAuth]);

  // Перенаправление неавторизованных пользователей
  useEffect(() => {
    if (isInitialized && !isLoading && !isAdminAuth) {
      router.push("/admin-login");
    }
  }, [isInitialized, isLoading, isAdminAuth, router]);

  // Показываем спиннер, пока идет инициализация
  if (!isInitialized || isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  // Если нет авторизации (будет перенаправление)
  if (!isAdminAuth || !adminData) {
    return null;
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <AdminHeader />
      
      <main className="container mx-auto px-4 pt-24 pb-12">
        <div className="max-w-4xl mx-auto">
          <h1 className="text-3xl font-bold mb-8">Профиль администратора</h1>
          
          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <div className="flex items-start md:items-center flex-col md:flex-row">
              <div className="w-20 h-20 bg-blue-100 rounded-full flex items-center justify-center mr-6 mb-4 md:mb-0">
                <FaUser className="text-blue-500 text-2xl" />
              </div>
              
              <div className="flex-grow">
                <h2 className="text-2xl font-semibold mb-1">{adminData.fio}</h2>
                <div className="flex items-center text-gray-600 mb-4">
                  <FaEnvelope className="mr-2" />
                  <span>{adminData.email}</span>
                </div>
                
                <div className="bg-blue-50 text-blue-700 px-3 py-1 rounded-full text-sm inline-flex items-center">
                  <FaCog className="mr-1" />
                  Администратор
                </div>
              </div>
            </div>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="bg-white p-6 rounded-lg shadow-md">
              <h3 className="text-xl font-semibold mb-4 flex items-center">
                <FaCalendarAlt className="mr-2 text-blue-500" />
                Управление мероприятиями
              </h3>
              <p className="text-gray-600 mb-4">
                Создавайте, редактируйте и управляйте мероприятиями на платформе.
              </p>
              <button 
                onClick={() => router.push("/edit-events")}
                className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors"
              >
                Перейти к мероприятиям
              </button>
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow-md">
              <h3 className="text-xl font-semibold mb-4 flex items-center">
                <FaCog className="mr-2 text-blue-500" />
                Настройки
              </h3>
              <p className="text-gray-600 mb-4">
                Управляйте настройками системы и вашего профиля.
              </p>
              <button 
                onClick={() => router.push("/dashboard")}
                className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors"
              >
                Перейти в панель управления
              </button>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}
================
File: frontend\src\app\(admin)\dashboard\page.tsx
"use client";
import { useState, ChangeEvent, useEffect, useContext, useCallback } from "react";
import { useRouter } from "next/navigation";
import InputField from "@/components/common/InputField";
import { FaSearch, FaUsers, FaCalendarAlt, FaPlus } from "react-icons/fa";
import AdminHeader from "@/components/AdminHeader";
import { AdminAuthContext } from "@/contexts/AdminAuthContext";
================
