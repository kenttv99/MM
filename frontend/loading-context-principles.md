# Базовые принципы и компоненты контекста загрузки

## Архитектура системы загрузки

### Важное обновление по импорту типов

При использовании системы загрузки необходимо правильно импортировать типы:

```typescript
// ❌ Неправильный импорт - может вызвать ошибки линтера
import { useLoading, LoadingStage } from '@/contexts/loading/LoadingContextLegacy';

// ✅ Правильный импорт - разделяйте импорты контекстов и типов
import { useLoading } from '@/contexts/loading/LoadingContextLegacy';
import { LoadingStage } from '@/contexts/loading/types';
```

Тип `LoadingStage` является перечислением, определенным в файле `types.ts` и должен импортироваться оттуда для обеспечения типовой безопасности.

### Порядок определения функций и замыкания

При реализации компонентов с несколькими функциональными обработчиками соблюдайте правильный порядок определения:

```typescript
// 1. Сначала определите основные функции, которые вызываются другими
const fetchWithFilters = useCallback(() => {
  // базовая логика запроса
}, [dependencies]);

// 2. Затем определите обработчики, которые используют основные функции
const handleReset = useCallback(() => {
  fetchWithFilters(initialState);
}, [fetchWithFilters, initialState]);

const handleApply = useCallback(() => {
  fetchWithFilters(currentFilters);
}, [fetchWithFilters, currentFilters]);
```

Этот порядок особенно важен при работе с фильтрами и состояниями загрузки данных.

## Фреймворк для загрузки компонентов

При создании компонентов с асинхронной загрузкой данных рекомендуется использовать следующий шаблон:

```typescript
// 1. Сервисные состояния и рефы
const isMounted = useIsMounted();
const abortControllerRef = useRef<AbortController | null>(null);
const hasInitialData = useRef<boolean>(false);

// 2. Хуки контекста загрузки
const { setStage, currentStage } = useLoading();
const { setError } = useLoadingError();

// 3. Локальные состояния
const [isFetching, setIsFetching] = useState(false);
const [data, setData] = useState(null);

// 4. Функция загрузки данных
const fetchData = useCallback(() => {
  // отмена предыдущего запроса и создание нового
  // обработка результатов
}, [dependencies]);

// 5. Эффект инициализации
useEffect(() => {
  isMounted.current = true;
  
  const timer = setTimeout(() => {
    if (isMounted.current) fetchData();
  }, 50);
  
  return () => {
    isMounted.current = false;
    clearTimeout(timer);
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
  };
}, [fetchData]);
```

Система загрузки в приложении построена на основе нескольких ключевых контекстов, которые взаимодействуют между собой для обеспечения плавного пользовательского опыта:

### 1. Модульная архитектура контекстов загрузки

В результате рефакторинга система загрузки была разделена на специализированные контексты:

**LoadingStageContext**:
- Управление текущей стадией загрузки (AUTHENTICATION, STATIC_CONTENT, DYNAMIC_CONTENT, COMPLETED)
- Контроль переходов между стадиями с валидацией
- Поддержание истории стадий для предотвращения циклов и регрессии
- Реализация автоматических таймаутов для прогрессии стадий

**LoadingFlagsContext**:
- Отслеживание динамических и статических состояний загрузки
- Управление флагами загрузки отдельно от стадий
- Предоставление функциональности сброса флагов

**LoadingErrorContext**:
- Обработка ошибок, связанных с загрузкой
- Предоставление методов установки и очистки ошибок
- Управление переходом к стадии ERROR

**LoadingProgressContext**:
- Отслеживание прогресса загрузки для визуальных индикаторов
- Управление процентом загрузки и состоянием завершения

**LoadingContextProvider**:
- Объединение всех специализированных контекстов
- Предоставление унифицированного интерфейса для обратной совместимости
- Обнаружение и исправление несоответствий загрузки

**Принципы работы**:
- Стадии загрузки проходят последовательно
- Автоматический переход к следующей стадии после таймаута (5 секунд)
- Защита от частых сбросов состояния (дебаунс 2 секунды)
- Отслеживание истории изменений стадий для предотвращения циклов и регрессии
- Строгое блокирование возврата к стадии AUTHENTICATION после перехода к другим стадиям
- Периодическая проверка и исправление несогласованности между флагами загрузки и стадиями (каждые 2 секунды)
- Автоматический сброс флагов загрузки при завершении всех запросов

### 1.1. Последовательность стадий загрузки

Приложение проходит через следующие стадии загрузки в строго определенной последовательности:

```
INITIAL → AUTHENTICATION → STATIC_CONTENT → DYNAMIC_CONTENT → COMPLETED
```

**INITIAL**:
- Начальная стадия при запуске приложения
- Длится очень короткое время перед автоматическим переходом к AUTHENTICATION
- Не позволяет выполнять никакие запросы

**AUTHENTICATION** (Аутентификация):
- Выполняется проверка аутентификации пользователя
- Разрешены только запросы к API аутентификации
- Блокирует большинство запросов к API, кроме авторизационных

**STATIC_CONTENT** (Статический контент):
- Загружаются статические элементы интерфейса (меню, шаблоны страниц, конфигурации)
- Разрешены запросы к API для публичного и статического контента
- Загружаются не зависящие от пользователя данные
- Выполняется первичное отображение UI

**DYNAMIC_CONTENT** (Динамический контент):
- Загружается контент, зависящий от пользователя
- Загружаются основные данные приложения (списки, детали и т.д.)
- Разрешены все запросы к API
- Отображаются персонализированные элементы интерфейса
- Показываются индикаторы загрузки данных (скелетоны)

**COMPLETED** (Завершено):
- Все ключевые данные загружены
- Приложение полностью функционально
- Разрешены все запросы к API
- Индикаторы загрузки скрыты

**ERROR** (Ошибка):
- Специальная стадия при критических ошибках
- Может вернуться к AUTHENTICATION для повторной попытки
- Отображает соответствующие сообщения об ошибках

**Переходы между стадиями**:
- Переходы между стадиями происходят либо автоматически по таймауту (5 секунд), либо через явные вызовы `setStage`
- Критически важные компоненты могут инициировать переход к нужной стадии
- Система предотвращает регрессию к предыдущим стадиям, особенно к AUTHENTICATION после ее завершения
- На каждой стадии API блокирует запросы, не соответствующие текущей стадии
- Автоматическая защита от зависания на стадии через таймауты гарантирует прогресс

**Мониторинг стадий**:
- Каждое изменение стадии логируется для отладки
- История изменений стадий отслеживается для выявления циклов
- Определяются и исправляются несоответствия между флагами загрузки и стадиями

### 2. Система валидации переходов между стадиями

Функция `canChangeStage` была централизована и стандартизирована:

```typescript
export function canChangeStage(
  currentStage: LoadingStage, 
  newStage: LoadingStage, 
  stageHistory: StageHistoryEntry[]
): StageChangeResult {
  // 1. Предотвращение регрессии к AUTHENTICATION
  if (newStage === LoadingStage.AUTHENTICATION) {
    const hasBeenPastAuth = stageHistory.some(
      entry => entry.stage !== LoadingStage.AUTHENTICATION && 
              entry.stage !== LoadingStage.INITIAL
    );
    
    if (hasBeenPastAuth) {
      return { 
        allowed: false, 
        reason: 'Regression to AUTHENTICATION after higher stages is not allowed' 
      };
    }
  }
  
  // 2. Проверка циклов изменения стадий
  const recentSameStageChanges = stageHistory
    .filter(entry => entry.stage === newStage && 
            Date.now() - entry.timestamp < 2000).length;
  
  if (recentSameStageChanges >= 3) {
    return { 
      allowed: false, 
      reason: 'Too many rapid changes to the same stage, potential cycle detected' 
    };
  }
  
  // 3. Пропуск, если стадия не изменилась
  if (newStage === currentStage) {
    return { 
      allowed: false, 
      reason: 'Stage is already set to this value' 
    };
  }
  
  // Переход разрешен
  return { allowed: true };
}
```

Это обеспечивает последовательную валидацию переходов между стадиями во всей кодовой базе.

### 3. AuthContext

**Основная ответственность**: Управление состоянием аутентификации пользователя.

**Ключевые компоненты**:
- `isAuthChecked` - флаг, указывающий, что проверка аутентификации завершена
- `isAuthenticated` - флаг, указывающий, что пользователь аутентифицирован
- `login`, `logout` - функции для управления аутентификацией
- `validateToken` - функция для проверки токена
- `handleUnauthorized` - обработчик событий авторизации

**Принципы работы**:
- Единственный источник истины для состояния аутентификации
- Автоматическая проверка токена при инициализации
- Самостоятельное уведомление LoadingContext о завершении проверки аутентификации через события
- Инициирование перехода к стадии STATIC_CONTENT после проверки, независимо от результата
- Защита от циклических проверок аутентификации

### 4. API и управление запросами

**Основная ответственность**: Выполнение запросов к API с учетом текущей стадии загрузки.

**Ключевые компоненты**:
- `apiFetch` - функция для выполнения запросов с кэшированием и обработкой ошибок
- `shouldProcessRequest` - функция для проверки, должен ли запрос быть обработан на текущей стадии
- `bypassLoadingStageCheck` - опция для обхода проверки стадии загрузки для критических запросов
- `clearCache` - функция для очистки кэша по паттерну URL
- Очередь запросов и механизм дедупликации с интервалом 50мс

**Функция управления запросами**:
```typescript
export function shouldProcessRequest(
  endpoint: string, 
  bypassLoadingStageCheck = false, 
  stage?: LoadingStage
): boolean {
  // Если установлен флаг bypass, пропускаем все проверки стадий загрузки
  if (bypassLoadingStageCheck) {
    return true;
  }
  
  // Если стадия не указана, используем текущую стадию загрузки
  const currentStage = stage || currentLoadingStage;

  // Всегда разрешаем определенные запросы, независимо от стадии
  if (ALLOWED_ENDPOINTS.ALWAYS_ALLOWED.some(
      pattern => endpoint.includes(pattern))) {
    return true;
  }
  
  // Обработка на основе текущей стадии загрузки
  switch (currentStage) {
    case LoadingStage.AUTHENTICATION:
      // Во время аутентификации разрешаем только эндпоинты аутентификации
      return endpoint.includes('/auth') || 
             endpoint.includes('/login') || 
             endpoint.includes('/token');
      
    case LoadingStage.STATIC_CONTENT:
      // Во время загрузки статического контента разрешаем статические эндпоинты
      return endpoint.includes('/static') ||
             endpoint.includes('/config') ||
             endpoint.includes('/i18n');
      
    case LoadingStage.COMPLETED:
    case LoadingStage.DYNAMIC_CONTENT:
      // На стадиях загрузки динамического контента или завершения разрешаем все запросы
      return true;
      
    default:
      // По умолчанию блокируем в неизвестных стадиях
      return false;
  }
}
```

**Конфигурация и ограничения**:
- Максимум 15 одновременных запросов
- Интервал дедупликации запросов: 50мс
- Время жизни кэша: 60 секунд с расширением для ранних стадий загрузки
- Таймаут запроса: 15 секунд
- Задержка сброса глобальной блокировки: 50мс
- Таймаут ожидания в очереди: 10 секунд

### 5. Обработка ошибок с типовой безопасностью

**Типы API-ответов**:
```typescript
// Утилита apiFetch теперь выбрасывает экземпляр ApiError при HTTP-ошибках
// Определение класса находится в utils/api.ts
export class ApiError extends Error {
  status: number; // HTTP статус код
  body: Record<string, unknown> | null; // Распарсенное тело ответа (JSON) или null

  // ... конструктор ...
}

// Отмена запроса (пример, не экспортируется)
// class ApiAborted extends Error { ... }

// Успешный ответ (любой тип T, не обязательно объект)
// type ApiSuccessResponse<T> = T;
```

**Паттерн безопасной обработки ответов (Обновлено)**:
Утилита `apiFetch` теперь сама обрабатывает HTTP-ошибки (`!response.ok`) и выбрасывает экземпляр `ApiError`. Успешные ответы возвращаются напрямую. Логика обработки в компонентах должна использовать `try...catch` и проверять тип ошибки.

```typescript
import { apiFetch } from '@/utils/api';
import { ApiError } from '@/utils/api'; // Импортируем класс ApiError

async function fetchDataExample() {
  try {
    // apiFetch возвращает распарсенные данные типа Т при успехе
    const data: ExpectedType = await apiFetch<ExpectedType>('/your/endpoint', options);
    
    // Обработка успешного ответа
    processSuccessData(data);
    
  } catch (err) {
    // Логируем исходную ошибку
    console.error("API request failed:", err);

    // Проверяем, является ли ошибка экземпляром ApiError
    if (err instanceof ApiError) {
      // Теперь у нас есть доступ к err.status и err.body (распарсенный JSON)
      console.error(`API Error: Status ${err.status}`, err.body);
      
      // Обрабатываем специфичные статус-коды
      if (err.status === 401) {
        handleUnauthorizedError();
      } else if (err.status === 422) {
        // Ошибка валидации - тело содержит детали
        const validationDetails = err.body?.detail; // FastAPI обычно помещает детали в поле 'detail'
        handleValidationError(validationDetails); 
      } else if (err.status === 404) {
        handleNotFoundError();
      } else {
        // Другие HTTP ошибки
        handleServerError(err.status, err.body);
      }
    } else if (err instanceof Error && err.name === 'AbortError') {
       // Обработка отмененного запроса (если используется AbortController)
       console.log("Request was aborted");
       handleAbortedRequest();
    } else {
      // Обработка других непредвиденных ошибок (сетевые проблемы, ошибки JS и т.д.)
      handleUnexpectedError(err instanceof Error ? err.message : 'An unknown error occurred');
    }
  }
}
```

Этот паттерн обеспечивает:
1.  Разделение логики для успешных и ошибочных ответов.
2.  Типобезопасный доступ к статусу и телу ошибки через проверку `instanceof ApiError`.
3.  Централизованную обработку ошибок в `apiFetch` и явное их выбрасывание.
4.  Обработку отмененных запросов и других непредвиденных ошибок.

### 6. Централизованная система логирования

**Конфигурация логгера**:
```typescript
// Настройка логирования для конкретных модулей
configureModuleLogging('API', {
  level: process.env.NODE_ENV === 'production' ? LogLevel.WARN : LogLevel.INFO,
  enabled: true,
  persistentContext: { 
    module: 'api',
    version: '1.0.0'
  }
});

// Создание логгеров с согласованным именованием
const apiLogger = createLogger('API');
const stageLogger = createLogger('LoadingStageContext');
const errorLogger = createLogger('LoadingErrorContext');
const flagsLogger = createLogger('LoadingFlagsContext');
```

**Функции логгера**:
- Уровни логирования для конкретных модулей (TRACE, DEBUG, INFO, WARN, ERROR)
- Постоянный контекст для согласованного логирования
- Структурированное форматирование логов
- Ограничение частоты логов для предотвращения переполнения
- Отслеживание метрик производительности
- Условное логирование на основе изменений значений

### 7. Компоненты интерфейса и индикация загрузки

**Основная ответственность**: Отображение интерфейса и взаимодействие с пользователем.

**Ключевые компоненты**:
- `Header` - шапка сайта с индикацией загрузки и аутентификации
- `EventsPage` - страница мероприятий с пагинацией и сортировкой
- `EventCardSkeleton` и `EventsSkeletonGrid` - компоненты для визуализации состояния загрузки
- `GlobalSpinner` - компонент глобального индикатора загрузки

**Принципы работы**:
- Отображение скелетона при загрузке данных
- Независимая загрузка данных для критически важных компонентов
- Гарантированная загрузка после таймаута и защиты от бесконечных скелетонов
- Обнаружение глобального спиннера в DOM для синхронизации с флагами загрузки
- Принудительное скрытие индикаторов загрузки при завершении запросов
- Специальная обработка админских маршрутов с ускоренным переходом к COMPLETED

## Оптимизация производительности

**Правила оптимизации запросов**:
1. Использование кэша для GET-запросов с расширенным TTL на ранних стадиях
2. Дедупликация запросов в окне 50 мс
3. Постановка запросов в очередь, когда активна глобальная блокировка
4. Отмена устаревших запросов с помощью AbortController
5. Ограничение частоты запросов для конкретных эндпоинтов
6. Обход проверки стадии загрузки для критически важных запросов

**Оптимизация состояния**:
1. Использование useRef для отслеживания состояния загрузки
2. Реализация дебаунсинга для изменений состояния (минимум 2 с)
3. Кэширование успешных ответов с адаптивным TTL
4. Очистка кэша по требованию или через интервал
5. Отслеживание истории запросов для дедупликации и отладки
6. Использование специализированных контекстов для предотвращения ненужных ререндеров

## Стратегия обработки ошибок

**Ошибки API (Обновлено)**:
1.  Сетевые ошибки (fetch не удался) → `apiFetch` выбросит стандартную ошибку `Error` (или `TypeError`).
2.  Ошибки таймаута → Прерывание запроса через `AbortController` (если сигнал передан в `apiFetch`), `apiFetch` выбросит `Error` с `name === 'AbortError'`.
3.  HTTP ошибки (`!response.ok`) → `apiFetch` выбросит экземпляр `ApiError`, содержащий `status` и распарсенное тело ответа `body` (JSON или `null`).
4.  Ошибки парсинга JSON (успешный ответ, но не JSON) → `apiFetch` выбросит `ApiError` (если статус `!ok`) или ошибку парсинга (если статус `ok`, но тело не JSON - требует проверки `transform`).
5.  Ошибки блокировки стадии → `apiFetch` выбросит `Error` с сообщением о блокировке *до* выполнения запроса.
6.  Ошибки лимитов запросов → `apiFetch` выбросит `Error` с сообщением о лимите *до* выполнения запроса.

**Ошибки загрузки**:
1. Регрессия стадий → Блокировка перехода с предупреждением
2. Ошибки аутентификации → Сохранение текущей стадии, без регрессии к AUTHENTICATION
3. Ошибки таймаута → Принудительный переход к следующей стадии через 5 секунд
4. Ошибки компонентов → Показ запасного UI
5. Несогласованные состояния загрузки → Автоматическое исправление через периодические проверки

## Паттерн безопасной интеграции с API (Заменено)

*(Этот раздел заменен обновленным разделом 5 "Обработка ошибок с типовой безопасностью")*

## Распространенные ошибки и их предотвращение

1. **Регрессия стадий**:
   - Никогда не разрешайте возврат к AUTHENTICATION после достижения более высоких стадий
   - Проверяйте историю стадий перед переходами
   - Логируйте попытки регрессии с контекстом

2. **Управление запросами**:
   - Всегда проверяйте стадию загрузки или используйте bypassLoadingStageCheck
   - Корректно обрабатывайте отмену запросов с помощью AbortController
   - Устанавливайте правильные таймауты для разных типов запросов
   - Используйте дедупликацию для частых запросов

3. **Управление состоянием**:
   - Используйте refs для отслеживания состояния загрузки, чтобы избежать проблем с рендерингом
   - Реализуйте правильный дебаунсинг с интервалами не менее 2 с
   - Очищайте состояние при размонтировании компонента и прерывайте ожидающие запросы
   - Обрабатывайте несогласованности загрузки с помощью detectAndFixLoadingInconsistency

4. **Обработка ошибок**:
   - Всегда используйте безопасный паттерн приведения типов (`as unknown as Type`)
   - Предоставляйте запасной UI для всех состояний загрузки
   - Реализуйте правильные границы ошибок
   - Логируйте ошибки с контекстной информацией
   - Обрабатывайте сетевые сбои с помощью расширенного TTL кэша

## Руководство по тестированию

**Критические тестовые случаи**:
1. Валидация переходов между стадиями, особенно предотвращение регрессии
2. Дедупликация запросов в сценариях с высокой частотой
3. Инвалидация кэша и поведение расширенного TTL
4. Обработка ошибок для различных сетевых сценариев
5. Обнаружение и исправление несогласованности состояния загрузки
6. Размонтирование компонентов с активными запросами
7. Стратегия восстановления после сетевых сбоев
8. Прогрессия стадий с таймаутами

## Правила сопровождения

1. **Изменения кода**:
   - Сохраняйте логику предотвращения регрессии
   - Поддерживайте порядок обработки запросов
   - Сохраняйте последовательность обработки ошибок
   - Обеспечивайте типовую безопасность с правильными паттернами приведения
   - Обновляйте документацию при внесении изменений

2. **Мониторинг производительности**:
   - Отслеживайте частоту успешных запросов по стадиям
   - Контролируйте время переходов между стадиями
   - Логируйте частоту попаданий в кэш для оптимизации
   - Отслеживайте исправления несогласованности загрузки

3. **Отладка**:
   - Используйте соответствующие уровни логирования (DEBUG, INFO, WARN, ERROR)
   - Отслеживайте историю стадий для обнаружения циклов
   - Контролируйте длину очереди запросов и их обработку
   - Проверяйте исправления несогласованности загрузки в консоли

## Особые случаи и сценарии

### Страница мероприятий (EventsPage)

Страница мероприятий имеет особую обработку в системе загрузки:
- **Независимый механизм загрузки**: Страница использует таймеры для гарантированной загрузки данных независимо от стадии
- **Безусловная загрузка данных**: Запрос данных происходит через короткий таймаут (200мс) после монтирования компонента
- **Обход проверки стадии**: Все запросы выполняются с опцией bypassLoadingStageCheck
- **Защита от зависания**: Предусмотрен таймаут в 2 секунды для гарантированного скрытия скелетона

### Администраторская панель и авторизация

Администраторская часть имеет специфические особенности взаимодействия с системой загрузки:
- **Ускоренный переход через стадии**: Админские маршруты автоматически быстро переходят к COMPLETED
- **Оптимизация проверки авторизации**: Многоуровневая стратегия с локальной валидацией
- **Автоматическое обновление токенов**: Middleware обновляет токены при приближении к концу срока действия
- **Защита от регрессии стадий**: Дополнительная проверка для предотвращения возврата к AUTHENTICATION
- **Кэширование данных профиля**: Сохранение профиля администратора в localStorage
- **Устойчивость к сетевым проблемам**: Использование локальной валидации при недоступности сервера
- **Отметка маршрутов**: Использование флага is_admin_route в localStorage для специальной обработки
- **Обработка сценариев истечения сессии**: Автоматическая очистка данных при получении 401/403 ответов

### Обработка фильтрации данных

Фильтрация данных в приложении требует особого внимания из-за специфики React:
- **Прямые API-запросы для критических операций**: Сброс фильтров выполняется через прямой запрос к API
- **Предотвращение проблем с замыканиями**: Использование текущих значений при выполнении запросов
- **Явное указание параметров запроса**: Гарантия корректных параметров в URL
- **Полный сброс состояния компонента**: При сбросе фильтров выполняется полное обнуление связанных значений
- **Обработка разных форматов API-ответов**: Универсальная обработка и форматирование ответов
- **Различная обработка в зависимости от UI-контекста**: Разное поведение при сбросе из разных компонентов
- **Подробное логирование операций**: Детальное отслеживание источника запросов и параметров

### Автоматический переход между стадиями

Система включает механизм автоматического перехода между стадиями:
- Таймауты для автоматического перехода к следующей стадии (5 секунд)
- Защита от застревания на одной стадии
- Логирование изменений стадий для отладки
- Строгое блокирование возвратов к предыдущим стадиям
- Отслеживание истории стадий для предотвращения циклов и регрессии
- Проверка наличия активных запросов перед переходом к следующей стадии

### Обнаружение и исправление несогласованности загрузки

Система постоянно отслеживает и исправляет несоответствия между флагами загрузки и стадиями:
- **Периодические проверки**: Каждые 2 секунды выполняется функция `detectAndFixLoadingInconsistency`
- **Проверка активных флагов**: Если флаги загрузки активны на поздних стадиях без активных запросов, они сбрасываются
- **Проверка завершения загрузки**: На ранних стадиях при отсутствии флагов загрузки происходит продвижение к следующей стадии
- **Автоматический переход к COMPLETED**: При завершении всех запросов на стадии DYNAMIC_CONTENT
- **Отслеживание DOM**: Проверка наличия глобального спиннера для синхронизации с состоянием загрузки
- **Принудительное обновление UI**: Гарантированное скрытие спиннера при завершении всех запросов
- **Таймеры безопасности**: Дополнительные проверки через 500мс и 1с после завершения запросов

## Рекомендации по разработке

1. **Загрузка данных в компонентах**:
   - Для критически важных данных используйте таймеры и bypassLoadingStageCheck
   - Добавляйте защиту от зависания с таймаутами для скрытия состояний загрузки
   - Отслеживайте статус загрузки через useRef для предотвращения повторных запросов
   - Используйте корректный сброс флагов загрузки при завершении запросов
   - Добавляйте обработку ошибок с таймаутами для гарантированного прогресса стадий

2. **Оптимизация запросов**:
   - Используйте кэширование для уменьшения количества запросов
   - Отменяйте ненужные запросы с помощью AbortController
   - Добавляйте защиту от слишком частых запросов
   - Используйте дедупликацию запросов с интервалом 50мс
   - Корректно обновляйте глобальный счетчик активных запросов

3. **Обработка ошибок**:
   - Логируйте ошибки с контекстом для упрощения отладки
   - Предоставляйте пользователю понятные сообщения
   - Не зависайте в состоянии загрузки при ошибках - используйте таймауты
   - Обязательно сбрасывайте флаги загрузки при получении ошибок
   - Обрабатывайте ошибки авторизации с отправкой события auth-unauthorized

4. **Производительность и UX**:
   - Всегда показывайте индикаторы загрузки, но ограничивайте их время отображения
   - Добавляйте защиту от мигания интерфейса при быстрой загрузке
   - Используйте скелетон-компоненты вместо спиннеров для лучшего UX
   - Гарантируйте отображение содержимого через таймауты безопасности
   - Используйте механизм обнаружения и исправления несогласованности

5. **Работа с токенами авторизации**:
   - Применяйте локальную валидацию JWT для снижения нагрузки на сервер
   - Используйте стратегию обновления токенов при приближении к сроку истечения
   - Реализуйте дебаунсинг для проверок состояния авторизации
   - Предусматривайте корректную обработку ошибок сети при проверке авторизации
   - Специально обрабатывайте админские маршруты для ускоренного перехода стадий

6. **Работа с флагами загрузки**:
   - Гарантируйте сброс флагов загрузки при завершении всех запросов
   - Используйте дополнительные таймеры для проверки состояния загрузки
   - Синхронизируйте глобальные флаги с внутренним состоянием компонентов
   - Проверяйте несогласованность между стадиями и флагами загрузки
   - Отслеживайте глобальный спиннер в DOM для точной синхронизации

## Обработка ошибок загрузки (обновленная)

В случае ошибок при загрузке данных, компоненты должны:

1.  Перехватить ошибку от `apiFetch` с помощью `try...catch`.
2.  Проверить тип ошибки (например, `instanceof ApiError` или `err.name === 'AbortError'`).
3.  Установить соответствующую стадию загрузки `setStage(LoadingStage.ERROR)` (используя `useLoadingStage`).
4.  Обновить состояние ошибки через общий контекст `setError(errorMessage)` (используя `useLoadingError`).
5.  Предоставить пользователю возможность повторить запрос.
6.  Правильно отменять предыдущие запросы перед новыми попытками (если применимо).

Пример обработки ошибок **(Обновлено)**:

```typescript
import { apiFetch, ApiError } from '@/utils/api'; // Импорт
import { useLoadingStage } from '@/contexts/loading/LoadingStageContext';
import { useLoadingError } from '@/contexts/loading/LoadingErrorContext';

// ... внутри компонента ...
const { setStage } = useLoadingStage();
const { setError } = useLoadingError();
const isMounted = useRef(true); // Пример отслеживания монтирования

// ... функция загрузки данных ...
const loadData = async () => {
  try {
    const result = await apiFetch<MyDataType>('/my/data');
    // Обработка успеха...
  } catch (err) {
    // Пропускаем отмененные запросы
    if (err instanceof Error && err.name === 'AbortError') {
      console.log("Data fetch aborted");
      return; 
    }
    
    let errorForUser = 'Произошла неизвестная ошибка';
    
    if (err instanceof ApiError) {
      // Обрабатываем ошибки API
      console.error(`API Error ${err.status}:`, err.body);
      if (err.status === 401) {
         errorForUser = 'Требуется авторизация.';
         // Возможно, перенаправить на логин или вызвать logout()
      } else if (err.status === 404) {
         errorForUser = 'Данные не найдены.';
      } else {
         // Используем сообщение из тела ошибки, если оно есть и строка
         if (err.body?.detail && typeof err.body.detail === 'string') {
            errorForUser = err.body.detail;
         } else {
            errorForUser = `Ошибка сервера (статус ${err.status})`;
         }
      }
    } else if (err instanceof Error) {
       // Другие ошибки (сеть, JS)
       console.error("Non-API error:", err);
       errorForUser = err.message;
    } else {
       console.error("Unknown error type:", err);
    }

    // Обновляем состояние и показываем ошибку, если компонент еще смонтирован
    if (isMounted.current) {
      setStage(LoadingStage.ERROR);
      setError(errorForUser);
    }
  } finally {
     // Сброс флагов загрузки и т.д.
  }
};

// ... useEffect для вызова loadData и очистки ...
``` 