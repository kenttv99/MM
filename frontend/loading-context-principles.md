# Базовые принципы и компоненты контекста загрузки

## Архитектура системы загрузки

### Важное обновление по импорту типов

При использовании системы загрузки необходимо правильно импортировать типы:

```typescript
// ❌ Неправильный импорт - может вызвать ошибки линтера
import { useLoading, LoadingStage } from '@/contexts/loading/LoadingContextLegacy';

// ✅ Правильный импорт - разделяйте импорты контекстов и типов
import { useLoading } from '@/contexts/loading/LoadingContextLegacy';
import { LoadingStage } from '@/contexts/loading/types';
```

Тип `LoadingStage` является перечислением, определенным в файле `types.ts` и должен импортироваться оттуда для обеспечения типовой безопасности.

### Порядок определения функций и замыкания

При реализации компонентов с несколькими функциональными обработчиками соблюдайте правильный порядок определения:

```typescript
// 1. Сначала определите основные функции, которые вызываются другими
const fetchWithFilters = useCallback(() => {
  // базовая логика запроса
}, [dependencies]);

// 2. Затем определите обработчики, которые используют основные функции
const handleReset = useCallback(() => {
  fetchWithFilters(initialState);
}, [fetchWithFilters, initialState]);

const handleApply = useCallback(() => {
  fetchWithFilters(currentFilters);
}, [fetchWithFilters, currentFilters]);
```

Этот порядок особенно важен при работе с фильтрами и состояниями загрузки данных.

## Фреймворк для загрузки компонентов

При создании компонентов с асинхронной загрузкой данных рекомендуется использовать следующий шаблон:

```typescript
// 1. Сервисные состояния и рефы
const isMounted = useIsMounted();
const abortControllerRef = useRef<AbortController | null>(null);
const hasInitialData = useRef<boolean>(false);

// 2. Хуки контекста загрузки
const { setStage, currentStage } = useLoading();
const { setError } = useLoadingError();

// 3. Локальные состояния
const [isFetching, setIsFetching] = useState(false);
const [data, setData] = useState(null);

// 4. Функция загрузки данных
const fetchData = useCallback(() => {
  // отмена предыдущего запроса и создание нового
  // обработка результатов
}, [dependencies]);

// 5. Эффект инициализации
useEffect(() => {
  isMounted.current = true;
  
  const timer = setTimeout(() => {
    if (isMounted.current) fetchData();
  }, 50);
  
  return () => {
    isMounted.current = false;
    clearTimeout(timer);
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
  };
}, [fetchData]);
```

Система загрузки в приложении построена на основе нескольких ключевых контекстов, которые взаимодействуют между собой для обеспечения плавного пользовательского опыта:

### 1. Модульная архитектура контекстов загрузки

В результате рефакторинга система загрузки была разделена на специализированные контексты:

**LoadingStageContext**:
- Управление текущей стадией загрузки (AUTHENTICATION, STATIC_CONTENT, DYNAMIC_CONTENT, COMPLETED)
- Контроль переходов между стадиями с валидацией
- Поддержание истории стадий для предотвращения циклов и регрессии
- Реализация автоматических таймаутов для прогрессии стадий

**LoadingFlagsContext**:
- Отслеживание динамических и статических состояний загрузки
- Управление флагами загрузки отдельно от стадий
- Предоставление функциональности сброса флагов

**LoadingErrorContext**:
- Обработка ошибок, связанных с загрузкой
- Предоставление методов установки и очистки ошибок
- Управление переходом к стадии ERROR

**LoadingProgressContext**:
- Отслеживание прогресса загрузки для визуальных индикаторов
- Управление процентом загрузки и состоянием завершения

**LoadingContextProvider**:
- Объединение всех специализированных контекстов
- Предоставление унифицированного интерфейса для обратной совместимости
- Обнаружение и исправление несоответствий загрузки

**Принципы работы**:
- Стадии загрузки проходят последовательно
- Автоматический переход к следующей стадии после таймаута (5 секунд)
- Защита от частых сбросов состояния (дебаунс 2 секунды)
- Отслеживание истории изменений стадий для предотвращения циклов и регрессии
- Строгое блокирование возврата к стадии AUTHENTICATION после перехода к другим стадиям
- Периодическая проверка и исправление несогласованности между флагами загрузки и стадиями (каждые 2 секунды)
- Автоматический сброс флагов загрузки при завершении всех запросов

### 1.1. Последовательность стадий загрузки

Приложение проходит через следующие стадии загрузки в строго определенной последовательности:

```
INITIAL → AUTHENTICATION → STATIC_CONTENT → DYNAMIC_CONTENT → COMPLETED
```

**INITIAL**:
- Начальная стадия при запуске приложения
- Длится очень короткое время перед автоматическим переходом к AUTHENTICATION
- Не позволяет выполнять никакие запросы

**AUTHENTICATION** (Аутентификация):
- Выполняется проверка аутентификации пользователя
- Разрешены только запросы к API аутентификации
- Блокирует большинство запросов к API, кроме авторизационных

**STATIC_CONTENT** (Статический контент):
- Загружаются статические элементы интерфейса (меню, шаблоны страниц, конфигурации)
- Разрешены запросы к API для публичного и статического контента
- Загружаются не зависящие от пользователя данные
- Выполняется первичное отображение UI

**DYNAMIC_CONTENT** (Динамический контент):
- Загружается контент, зависящий от пользователя
- Загружаются основные данные приложения (списки, детали и т.д.)
- Разрешены все запросы к API
- Отображаются персонализированные элементы интерфейса
- Показываются индикаторы загрузки данных (скелетоны)

**COMPLETED** (Завершено):
- Все ключевые данные загружены
- Приложение полностью функционально
- Разрешены все запросы к API
- Индикаторы загрузки скрыты

**ERROR** (Ошибка):
- Специальная стадия при критических ошибках
- Может вернуться к AUTHENTICATION для повторной попытки
- Отображает соответствующие сообщения об ошибках

**Переходы между стадиями**:
- Переходы между стадиями происходят либо автоматически по таймауту (5 секунд), либо через явные вызовы `setStage`
- Критически важные компоненты могут инициировать переход к нужной стадии
- Система предотвращает регрессию к предыдущим стадиям, особенно к AUTHENTICATION после ее завершения
- На каждой стадии API блокирует запросы, не соответствующие текущей стадии
- Автоматическая защита от зависания на стадии через таймауты гарантирует прогресс

**Мониторинг стадий**:
- Каждое изменение стадии логируется для отладки
- История изменений стадий отслеживается для выявления циклов
- Определяются и исправляются несоответствия между флагами загрузки и стадиями

### 2. Система валидации переходов между стадиями

Функция `canChangeStage` была централизована и стандартизирована:

```typescript
export function canChangeStage(
  currentStage: LoadingStage, 
  newStage: LoadingStage, 
  stageHistory: StageHistoryEntry[]
): StageChangeResult {
  // 1. Предотвращение регрессии к AUTHENTICATION
  if (newStage === LoadingStage.AUTHENTICATION) {
    const hasBeenPastAuth = stageHistory.some(
      entry => entry.stage !== LoadingStage.AUTHENTICATION && 
              entry.stage !== LoadingStage.INITIAL
    );
    
    if (hasBeenPastAuth) {
      return { 
        allowed: false, 
        reason: 'Regression to AUTHENTICATION after higher stages is not allowed' 
      };
    }
  }
  
  // 2. Проверка циклов изменения стадий
  const recentSameStageChanges = stageHistory
    .filter(entry => entry.stage === newStage && 
            Date.now() - entry.timestamp < 2000).length;
  
  if (recentSameStageChanges >= 3) {
    return { 
      allowed: false, 
      reason: 'Too many rapid changes to the same stage, potential cycle detected' 
    };
  }
  
  // 3. Пропуск, если стадия не изменилась
  if (newStage === currentStage) {
    return { 
      allowed: false, 
      reason: 'Stage is already set to this value' 
    };
  }
  
  // Переход разрешен
  return { allowed: true };
}
```

Это обеспечивает последовательную валидацию переходов между стадиями во всей кодовой базе.

### 3. AuthContext

**Основная ответственность**: Управление состоянием аутентификации пользователя.

**Ключевые компоненты**:
- `isAuthChecked` - флаг, указывающий, что проверка аутентификации завершена
- `isAuthenticated` - флаг, указывающий, что пользователь аутентифицирован
- `login`, `logout` - функции для управления аутентификацией
- `validateToken` - функция для проверки токена
- `handleUnauthorized` - обработчик событий авторизации

**Принципы работы**:
- Единственный источник истины для состояния аутентификации
- Автоматическая проверка токена при инициализации
- Самостоятельное уведомление LoadingContext о завершении проверки аутентификации через события
- Инициирование перехода к стадии STATIC_CONTENT после проверки, независимо от результата
- Защита от циклических проверок аутентификации

### 4. API и управление запросами

**Основная ответственность**: Выполнение запросов к API с учетом текущей стадии загрузки.

**Ключевые компоненты**:
- `apiFetch` - функция для выполнения запросов с кэшированием и обработкой ошибок
- `shouldProcessRequest` - функция для проверки, должен ли запрос быть обработан на текущей стадии
- `bypassLoadingStageCheck` - опция для обхода проверки стадии загрузки для критических запросов
- `clearCache` - функция для очистки кэша по паттерну URL
- Очередь запросов и механизм дедупликации с интервалом 50мс

**Функция управления запросами**:
```typescript
export function shouldProcessRequest(
  endpoint: string, 
  bypassLoadingStageCheck = false, 
  stage?: LoadingStage
): boolean {
  // Если установлен флаг bypass, пропускаем все проверки стадий загрузки
  if (bypassLoadingStageCheck) {
    return true;
  }
  
  // Если стадия не указана, используем текущую стадию загрузки
  const currentStage = stage || currentLoadingStage;

  // Всегда разрешаем определенные запросы, независимо от стадии
  if (ALLOWED_ENDPOINTS.ALWAYS_ALLOWED.some(
      pattern => endpoint.includes(pattern))) {
    return true;
  }
  
  // Обработка на основе текущей стадии загрузки
  switch (currentStage) {
    case LoadingStage.AUTHENTICATION:
      // Во время аутентификации разрешаем только эндпоинты аутентификации
      return endpoint.includes('/auth') || 
             endpoint.includes('/login') || 
             endpoint.includes('/token');
      
    case LoadingStage.STATIC_CONTENT:
      // Во время загрузки статического контента разрешаем статические эндпоинты
      return endpoint.includes('/static') ||
             endpoint.includes('/config') ||
             endpoint.includes('/i18n');
      
    case LoadingStage.COMPLETED:
    case LoadingStage.DYNAMIC_CONTENT:
      // На стадиях загрузки динамического контента или завершения разрешаем все запросы
      return true;
      
    default:
      // По умолчанию блокируем в неизвестных стадиях
      return false;
  }
}
```

**Конфигурация и ограничения**:
- Максимум 15 одновременных запросов
- Интервал дедупликации запросов: 50мс
- Время жизни кэша: 60 секунд с расширением для ранних стадий загрузки
- Таймаут запроса: 15 секунд
- Задержка сброса глобальной блокировки: 50мс
- Таймаут ожидания в очереди: 10 секунд

### 5. Обработка ошибок с типовой безопасностью

**Типы API-ответов**:
```typescript
export interface ApiErrorResponse {
  error: string;
  status: number;
}

export interface ApiAbortedResponse {
  aborted: boolean;
  reason?: string;
}
```

**Паттерн безопасной обработки ответов**:
```typescript
if ('aborted' in response) {
  const abortedResponse = response as unknown as ApiAbortedResponse;
  // Обработка прерванного запроса
  logError("Request aborted", abortedResponse.reason);
  return null;
}

if ('error' in response) {
  const errorResponse = response as unknown as ApiErrorResponse;
  // Обработка ответа с ошибкой
  logError("Error in response", errorResponse.error);
  return null;
}
```

Этот паттерн обеспечивает типовую безопасность при работе с разными формами ответов путем:
1. Использования оператора `in` для проверки наличия свойства
2. Приведения типов с помощью `as unknown as TargetType` для максимальной безопасности
3. Соответствующей обработки каждого типа ответа

### 6. Централизованная система логирования

**Конфигурация логгера**:
```typescript
// Настройка логирования для конкретных модулей
configureModuleLogging('API', {
  level: process.env.NODE_ENV === 'production' ? LogLevel.WARN : LogLevel.INFO,
  enabled: true,
  persistentContext: { 
    module: 'api',
    version: '1.0.0'
  }
});

// Создание логгеров с согласованным именованием
const apiLogger = createLogger('API');
const stageLogger = createLogger('LoadingStageContext');
const errorLogger = createLogger('LoadingErrorContext');
const flagsLogger = createLogger('LoadingFlagsContext');
```

**Функции логгера**:
- Уровни логирования для конкретных модулей (TRACE, DEBUG, INFO, WARN, ERROR)
- Постоянный контекст для согласованного логирования
- Структурированное форматирование логов
- Ограничение частоты логов для предотвращения переполнения
- Отслеживание метрик производительности
- Условное логирование на основе изменений значений

### 7. Компоненты интерфейса и индикация загрузки

**Основная ответственность**: Отображение интерфейса и взаимодействие с пользователем.

**Ключевые компоненты**:
- `Header` - шапка сайта с индикацией загрузки и аутентификации
- `EventsPage` - страница мероприятий с пагинацией и сортировкой
- `EventCardSkeleton` и `EventsSkeletonGrid` - компоненты для визуализации состояния загрузки
- `GlobalSpinner` - компонент глобального индикатора загрузки

**Принципы работы**:
- Отображение скелетона при загрузке данных
- Независимая загрузка данных для критически важных компонентов
- Гарантированная загрузка после таймаута и защиты от бесконечных скелетонов
- Обнаружение глобального спиннера в DOM для синхронизации с флагами загрузки
- Принудительное скрытие индикаторов загрузки при завершении запросов
- Специальная обработка админских маршрутов с ускоренным переходом к COMPLETED

## Оптимизация производительности

**Правила оптимизации запросов**:
1. Использование кэша для GET-запросов с расширенным TTL на ранних стадиях
2. Дедупликация запросов в окне 50 мс
3. Постановка запросов в очередь, когда активна глобальная блокировка
4. Отмена устаревших запросов с помощью AbortController
5. Ограничение частоты запросов для конкретных эндпоинтов
6. Обход проверки стадии загрузки для критически важных запросов

**Оптимизация состояния**:
1. Использование useRef для отслеживания состояния загрузки
2. Реализация дебаунсинга для изменений состояния (минимум 2 с)
3. Кэширование успешных ответов с адаптивным TTL
4. Очистка кэша по требованию или через интервал
5. Отслеживание истории запросов для дедупликации и отладки
6. Использование специализированных контекстов для предотвращения ненужных ререндеров

## Стратегия обработки ошибок

**Ошибки API**:
1. Сетевые ошибки → Возврат структурированного объекта ошибки
2. Ошибки таймаута → Прерывание запроса через AbortController
3. Ошибки парсинга JSON → Правильное форматирование для не-JSON ответов
4. Ошибки блокировки стадии → Постановка в очередь или обход проверки
5. Ошибки глобальной блокировки → Использование кэша или очереди в зависимости от доступности

**Ошибки загрузки**:
1. Регрессия стадий → Блокировка перехода с предупреждением
2. Ошибки аутентификации → Сохранение текущей стадии, без регрессии к AUTHENTICATION
3. Ошибки таймаута → Принудительный переход к следующей стадии через 5 секунд
4. Ошибки компонентов → Показ запасного UI
5. Несогласованные состояния загрузки → Автоматическое исправление через периодические проверки

## Паттерн безопасной интеграции с API

При интеграции с API-ответами следуйте этому паттерну для типовой безопасности:

```typescript
try {
  const response = await apiFetch<ExpectedType>(url, options);
  
  if ('aborted' in response) {
    const abortedResponse = response as unknown as ApiAbortedResponse;
    handleAbortedRequest(abortedResponse.reason);
    return;
  }
  
  if ('error' in response) {
    const errorResponse = response as unknown as ApiErrorResponse;
    handleErrorResponse(errorResponse.error, errorResponse.status);
    return;
  }
  
  // Обработка успешного ответа
  processData(response);
} catch (err) {
  // Обработка непредвиденных ошибок
  handleUnexpectedError(err);
}
```

Этот паттерн обеспечивает правильную проверку типов и обработку ошибок для всех взаимодействий с API.

## Распространенные ошибки и их предотвращение

1. **Регрессия стадий**:
   - Никогда не разрешайте возврат к AUTHENTICATION после достижения более высоких стадий
   - Проверяйте историю стадий перед переходами
   - Логируйте попытки регрессии с контекстом

2. **Управление запросами**:
   - Всегда проверяйте стадию загрузки или используйте bypassLoadingStageCheck
   - Корректно обрабатывайте отмену запросов с помощью AbortController
   - Устанавливайте правильные таймауты для разных типов запросов
   - Используйте дедупликацию для частых запросов

3. **Управление состоянием**:
   - Используйте refs для отслеживания состояния загрузки, чтобы избежать проблем с рендерингом
   - Реализуйте правильный дебаунсинг с интервалами не менее 2 с
   - Очищайте состояние при размонтировании компонента и прерывайте ожидающие запросы
   - Обрабатывайте несогласованности загрузки с помощью detectAndFixLoadingInconsistency

4. **Обработка ошибок**:
   - Всегда используйте безопасный паттерн приведения типов (`as unknown as Type`)
   - Предоставляйте запасной UI для всех состояний загрузки
   - Реализуйте правильные границы ошибок
   - Логируйте ошибки с контекстной информацией
   - Обрабатывайте сетевые сбои с помощью расширенного TTL кэша

## Руководство по тестированию

**Критические тестовые случаи**:
1. Валидация переходов между стадиями, особенно предотвращение регрессии
2. Дедупликация запросов в сценариях с высокой частотой
3. Инвалидация кэша и поведение расширенного TTL
4. Обработка ошибок для различных сетевых сценариев
5. Обнаружение и исправление несогласованности состояния загрузки
6. Размонтирование компонентов с активными запросами
7. Стратегия восстановления после сетевых сбоев
8. Прогрессия стадий с таймаутами

## Правила сопровождения

1. **Изменения кода**:
   - Сохраняйте логику предотвращения регрессии
   - Поддерживайте порядок обработки запросов
   - Сохраняйте последовательность обработки ошибок
   - Обеспечивайте типовую безопасность с правильными паттернами приведения
   - Обновляйте документацию при внесении изменений

2. **Мониторинг производительности**:
   - Отслеживайте частоту успешных запросов по стадиям
   - Контролируйте время переходов между стадиями
   - Логируйте частоту попаданий в кэш для оптимизации
   - Отслеживайте исправления несогласованности загрузки

3. **Отладка**:
   - Используйте соответствующие уровни логирования (DEBUG, INFO, WARN, ERROR)
   - Отслеживайте историю стадий для обнаружения циклов
   - Контролируйте длину очереди запросов и их обработку
   - Проверяйте исправления несогласованности загрузки в консоли

## Особые случаи и сценарии

### Страница мероприятий (EventsPage)

Страница мероприятий имеет особую обработку в системе загрузки:
- **Независимый механизм загрузки**: Страница использует таймеры для гарантированной загрузки данных независимо от стадии
- **Безусловная загрузка данных**: Запрос данных происходит через короткий таймаут (200мс) после монтирования компонента
- **Обход проверки стадии**: Все запросы выполняются с опцией bypassLoadingStageCheck
- **Защита от зависания**: Предусмотрен таймаут в 2 секунды для гарантированного скрытия скелетона

### Администраторская панель и авторизация

Администраторская часть имеет специфические особенности взаимодействия с системой загрузки:
- **Ускоренный переход через стадии**: Админские маршруты автоматически быстро переходят к COMPLETED
- **Оптимизация проверки авторизации**: Многоуровневая стратегия с локальной валидацией
- **Автоматическое обновление токенов**: Middleware обновляет токены при приближении к концу срока действия
- **Защита от регрессии стадий**: Дополнительная проверка для предотвращения возврата к AUTHENTICATION
- **Кэширование данных профиля**: Сохранение профиля администратора в localStorage
- **Устойчивость к сетевым проблемам**: Использование локальной валидации при недоступности сервера
- **Отметка маршрутов**: Использование флага is_admin_route в localStorage для специальной обработки
- **Обработка сценариев истечения сессии**: Автоматическая очистка данных при получении 401/403 ответов

### Обработка фильтрации данных

Фильтрация данных в приложении требует особого внимания из-за специфики React:
- **Прямые API-запросы для критических операций**: Сброс фильтров выполняется через прямой запрос к API
- **Предотвращение проблем с замыканиями**: Использование текущих значений при выполнении запросов
- **Явное указание параметров запроса**: Гарантия корректных параметров в URL
- **Полный сброс состояния компонента**: При сбросе фильтров выполняется полное обнуление связанных значений
- **Обработка разных форматов API-ответов**: Универсальная обработка и форматирование ответов
- **Различная обработка в зависимости от UI-контекста**: Разное поведение при сбросе из разных компонентов
- **Подробное логирование операций**: Детальное отслеживание источника запросов и параметров

### Автоматический переход между стадиями

Система включает механизм автоматического перехода между стадиями:
- Таймауты для автоматического перехода к следующей стадии (5 секунд)
- Защита от застревания на одной стадии
- Логирование изменений стадий для отладки
- Строгое блокирование возвратов к предыдущим стадиям
- Отслеживание истории стадий для предотвращения циклов и регрессии
- Проверка наличия активных запросов перед переходом к следующей стадии

### Обнаружение и исправление несогласованности загрузки

Система постоянно отслеживает и исправляет несоответствия между флагами загрузки и стадиями:
- **Периодические проверки**: Каждые 2 секунды выполняется функция `detectAndFixLoadingInconsistency`
- **Проверка активных флагов**: Если флаги загрузки активны на поздних стадиях без активных запросов, они сбрасываются
- **Проверка завершения загрузки**: На ранних стадиях при отсутствии флагов загрузки происходит продвижение к следующей стадии
- **Автоматический переход к COMPLETED**: При завершении всех запросов на стадии DYNAMIC_CONTENT
- **Отслеживание DOM**: Проверка наличия глобального спиннера для синхронизации с состоянием загрузки
- **Принудительное обновление UI**: Гарантированное скрытие спиннера при завершении всех запросов
- **Таймеры безопасности**: Дополнительные проверки через 500мс и 1с после завершения запросов

## Рекомендации по разработке

1. **Загрузка данных в компонентах**:
   - Для критически важных данных используйте таймеры и bypassLoadingStageCheck
   - Добавляйте защиту от зависания с таймаутами для скрытия состояний загрузки
   - Отслеживайте статус загрузки через useRef для предотвращения повторных запросов
   - Используйте корректный сброс флагов загрузки при завершении запросов
   - Добавляйте обработку ошибок с таймаутами для гарантированного прогресса стадий

2. **Оптимизация запросов**:
   - Используйте кэширование для уменьшения количества запросов
   - Отменяйте ненужные запросы с помощью AbortController
   - Добавляйте защиту от слишком частых запросов
   - Используйте дедупликацию запросов с интервалом 50мс
   - Корректно обновляйте глобальный счетчик активных запросов

3. **Обработка ошибок**:
   - Логируйте ошибки с контекстом для упрощения отладки
   - Предоставляйте пользователю понятные сообщения
   - Не зависайте в состоянии загрузки при ошибках - используйте таймауты
   - Обязательно сбрасывайте флаги загрузки при получении ошибок
   - Обрабатывайте ошибки авторизации с отправкой события auth-unauthorized

4. **Производительность и UX**:
   - Всегда показывайте индикаторы загрузки, но ограничивайте их время отображения
   - Добавляйте защиту от мигания интерфейса при быстрой загрузке
   - Используйте скелетон-компоненты вместо спиннеров для лучшего UX
   - Гарантируйте отображение содержимого через таймауты безопасности
   - Используйте механизм обнаружения и исправления несогласованности

5. **Работа с токенами авторизации**:
   - Применяйте локальную валидацию JWT для снижения нагрузки на сервер
   - Используйте стратегию обновления токенов при приближении к сроку истечения
   - Реализуйте дебаунсинг для проверок состояния авторизации
   - Предусматривайте корректную обработку ошибок сети при проверке авторизации
   - Специально обрабатывайте админские маршруты для ускоренного перехода стадий

6. **Работа с флагами загрузки**:
   - Гарантируйте сброс флагов загрузки при завершении всех запросов
   - Используйте дополнительные таймеры для проверки состояния загрузки
   - Синхронизируйте глобальные флаги с внутренним состоянием компонентов
   - Проверяйте несогласованность между стадиями и флагами загрузки
   - Отслеживайте глобальный спиннер в DOM для точной синхронизации

## Обработка ошибок загрузки (обновленная)

В случае ошибок при загрузке данных, компоненты должны:

1. Проверять состояние монтирования через `isMounted.current`
2. Устанавливать соответствующую стадию загрузки `setStage(LoadingStage.ERROR)`
3. Обновлять состояние ошибки через общий контекст `setError(errorMessage)`
4. Предоставлять пользователю возможность повторить запрос
5. Правильно отменять предыдущие запросы перед новыми попытками

Пример обработки ошибок:

```typescript
.catch(error => {
  // Пропускаем отмененные запросы
  if (error instanceof Error && error.name === 'AbortError') {
    return;
  }
  
  // Логируем ошибку
  logger.error('Error fetching data', { error });
  
  // Обновляем состояние и показываем ошибку
  if (isMounted.current) {
    setStage(LoadingStage.ERROR);
    setError(error instanceof Error ? error.message : 'Произошла ошибка');
  }
})
```

### Компонент отображения ошибки

Рекомендуется использовать единый паттерн для отображения ошибок:

```tsx
if (currentStage === LoadingStage.ERROR) {
  return (
    <div className="p-8 text-center">
      <h2 className="text-xl font-semibold text-red-600 mb-4">Произошла ошибка</h2>
      <p className="text-gray-700 mb-4">{loadingErrorFromContext}</p>
      <button onClick={handleRetry} className="px-4 py-2 bg-orange-500 text-white rounded-lg">
        Попробовать снова
      </button>
    </div>
  );
}
```

### Отмена запросов при изменении параметров

При изменении параметров запроса (например, фильтров) необходимо отменять предыдущие запросы:

```typescript
// Отменяем предыдущий запрос
if (abortControllerRef.current) {
  abortControllerRef.current.abort();
  abortControllerRef.current = null;
}

// Создаем новый контроллер
abortControllerRef.current = new AbortController();
const signal = abortControllerRef.current.signal;

// Используем signal в запросе
fetchService(parameters, signal);
``` 